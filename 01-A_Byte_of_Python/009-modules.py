""" Модули """


""" Как можно использовать код повторно, помещая его в функции, мы уже видели.
А что, если нам понадобится повторно использовать различные функции в других
наших программах? Как вы уже, наверное, догадались, ответ -
модули.

Существуют разные способы составления модулей, но самый простой - это создать
файл с расширением .py, содержащий функции и переменные.

Другой способ - написать модуль на том языке программирования, на котором
написан сам интерпретатор Python. Например, можно писать модули на языке
программирования C, которые после компиляции могут использоваться стандартным
интерпретатором Python.

Модуль можно импортировать в другую программу, чтобы использовать функции из
него. Точно так же мы используем стандартную библиотеку Python. Сперва
посмотрим, как использовать модули стандартной библиотеки. """

""" Пример: (сохраните как using_sys.py) """

import sys

print('Аргументы командной строки:')
for i in sys.argv:
    print(i)

print('\n\nПеременная PYTHONPATH содержит', sys.path, '\n')

""" $ python3 using_sys.py we are arguments
    Аргументы командной строки:
    using_sys.py
    we
    are
    arguments

    Переменная PYTHONPATH содержит ['/home/scyth1an/projects/GitHub -
    Python/Learn_Python/01-A_Byte_of_Python/009-modules/01-modules',
    '/home/scyth1an/anaconda3/lib/python38.zip',
    '/home/scyth1an/anaconda3/lib/python3.8',
    '/home/scyth1an/anaconda3/lib/python3.8/lib-dynload',
    '/home/scyth1an/.local/lib/python3.8/site-packages',
    '/home/scyth1an/anaconda3/lib/python3.8/site-packages']

"""

""" Как это работает: """

"""

    В начале мы импортируем модуль sys командой import. Этим мы говорим Python,
    что хотим использовать этот модуль. Модуль sys содержит функции,
    относящиеся к интерпретатору Python и его среде, т.е. к системе (system).

    Когда Python выполняет команду import sys, он ищет модуль sys. В данном
    случае это один из встроенных модулей, и Python знает, где его искать.

    Если бы это был не скомпилированный модуль, т.е. модуль, написанный на
    Python, тогда интерпретатор Python искал бы его в каталогах, перечисленных
    в переменной sys.path. Если модуль найден, выполняются команды в теле
    модуля, и он становится доступным. Обратите внимание, что инициализация[1]
    происходит только при первом импорте модуля.

    Доступ к переменной argv в модуле sys предоставляется при помощи точки,
    т.е. sys.argv. Это явно показывает, что это имя является частью модуля sys.
    Ещё одним преимуществом такого обозначения является то, что имя не
    конфликтует с именем переменной argv, которая может использоваться в вашей
    программе.

    Переменная sys.argv является списком строк (списки будут детально
    обсуждаться в одной из последующих глав). Она содержит список аргументов
    командной строки, т.е. аргументов, переданных программе из командной
    строки.

    Если вы используете среду разработки[2] для написания и запуска программ,
    поищите где-нибудь в её меню возможность передавать параметры командной
    строки.

    В нашем примере, когда мы запускаем "python using_sys.py we are arguments",
    мы запускаем модуль using_sys.py командой python, а всё, что следует
    далее - аргументы, передаваемые программе[3]. Python сохраняет аргументы
    командной строки в переменной sys.argv для дальнейшего использования.

    Помните, что имя запускаемого сценария[4] всегда является первым аргументом
    в списке sys.argv. Так что в приведённом примере 'using_sys.py' будет
    элементом sys.argv[0], 'we' - sys.argv[1], 'are' - sys.argv[2], а
    'arguments' - sys.argv[3]. Помните, что в Python нумерация начинается с 0,
    а не с 1.

    sys.path содержит список имён каталогов, откуда импортируются модули.
    Заметьте, что первая строка в sys.path пуста; эта пустая строка показывает,
    что текущая директория также является частью sys.path, которая совпадает со
    значением переменной окружения PYTHONPATH. Это означает, что модули,
    расположенные в текущем каталоге, можно импортировать напрямую. В противном
    случае придётся поместить свой модуль в один из каталогов, перечисленных в
    sys.path.

    Помните, что текущий каталог - это каталог, в котором была запущена
    программа. Выполните "import os; print(os.getcwd())", чтобы узнать текущий
    каталог программы.

"""


""" Файлы байткода .pyc """


""" Импорт модуля - относительно дорогостоящее мероприятие, поэтому Python
предпринимает некоторые трюки для ускорения этого процесса. Один из способов -
создать байт-компилированные файлы (или байткод) с расширением .pyc, которые
являются некой промежуточной формой, в которую Python переводит программу
(помните раздел "Введение" о том, как работает Python?). Такой файл .pyc
полезен при импорте модуля в следующий раз в другую программу - это произойдёт
намного быстрее, поскольку значительная часть обработки, требуемой при импорте
модуля, будет уже проделана. Этот байткод также является платформо-независимым.

"""

""" Примечание: Обычно файлы .pyc создаются в том же каталоге, где расположены
и соответствующие им файлы .py. Если Python не может получить доступ для записи
файлов в этот каталог, файлы .pyc созданы не будут.  """


""" Оператор from ... import ... """


""" Чтобы импортировать переменную argv прямо в программу и не писать всякий
раз sys. при обращении к ней, можно воспользоваться выражением "from sys import
argv".

Для импорта всех имён, использующихся в модуле sys, можно выполнить команду
"from sys import *". Это работает для любых модулей.

В общем случае вам следует избегать использования этого оператора и
использовать вместо этого оператор import, чтобы предотвратить конфликты имён
и не затруднять чтение программы. """

""" Пример: """

from math import *
n = int(input("Введите диапазон:-  "))
p = [2, 3]
count = 2
a = 5
while (count < n):
    b = 0
    for i in range(2, a):
        if (i <= sqrt(a)):
            if (a % i == 0):
                print(a, "непростое")
                b = 1
            else:
                pass

    if (b != 1):
        print(a, "простое")
        p = p + [a]
    count = count + 1
    a = a + 2
print(p)


""" Имя модуля - __name__ """


""" У каждого модуля есть имя, и команды в модуле могут узнать имя их модуля.
Это полезно, когда нужно знать, запущен ли модуль как самостоятельная программа
или импортирован. Как уже упоминалось выше, когда модуль импортируется впервые,
содержащийся в нём код исполняется. Мы можем воспользоваться этим для того,
чтобы заставить модуль вести себя по-разному в зависимости от того,
используется ли он сам по себе или импортируется в другую программа. Этого
можно достичь с применением атрибута модуля под названием __name__. """

""" Пример: (сохраните как using_name.py) """

if __name__ == '__main__':
    print('Эта программа запущена сама по себе.')
else:
    print('Меня импортировали в другой модуль.')

""" Вывод: """

""" $ python3 using_name.py
    Эта программа запущена сама по себе.

    $ python3
    >>> import using_name
    Меня импортировали в другой модуль.
    >>>

"""

""" Как это работает: """

""" В каждом модуле Python определено его имя - __name__[5] . Если оно равно
'__main__', это означает, что модуль запущен самостоятельно пользователем, и мы
можем выполнить соответствующие действия.

"""


""" Создание собственных модулей """
""" Создать собственный модуль очень легко. Да вы всё время делали это! Ведь
каждая программа на Python также является и модулем. Необходимо лишь убедиться,
что у неё установлено расширение .py. Следующий пример объяснит это.

"""

""" Пример: (сохраните как mymodule.py) """
