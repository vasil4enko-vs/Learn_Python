# 3.7. Срезы списков. Операторы сравнения списков

На этом занятии продолжим изучение списков языка программирования Python.

Сегодня мы начнём занятие с изучения срезов списков.

## 3.7.1. Срезы списков

О срезах мы уже говорили, когда рассматривали строки и с их помощью выделяли наборы символов и строк. Со списками всё работает аналогично.

**Срезы списков** - встроенный инструмент языка, позволяющий работать с определенной частью списка.

Синтаксис:

```python
some_list[start:stop:step]
```

Параметры:

`start` — индекс элемента, с которого должна начаться выборка.
`stop` — индекс элемента, перед которым диапазон выборки должен закончиться (т.е. элемент под этим индексом не входит в выборку).
`step` — шаг прироста выбираемых индексов (по умолчанию равен 1).

Срезы позволяют выделять наборы элементов из списка.

Например, у нас есть такой список:

| Индексы | 0      | 1   | 2     | 3      |
|:-------:|:------:|:---:|:-----:|:------:|
| lst =   | Москва | Уфа | Тверь | Казань |

И мы хотим из него выделить второй и третий элементы. В нашем случае срез будет выглядеть таким образом:

```python
>>> lst = ["Москва", "Уфа", "Тверь", "Казань"]
>>> lst[1:3]
['Уфа', 'Тверь']
>>>
```

На выходе мы получим новый список с двумя элементами, старый же список `lst` остаётся без изменений.

Если присвоить какой-либо переменной результат этого среза:

```python
>>> a = lst[1:3]
>>> a
['Уфа', 'Тверь']
>>>
```

и в переменной `a` изменить первый элемент:

```python
>>> a[0] = "Воронеж"
>>> a
['Воронеж', 'Тверь']
>>>
```

коллекция `a` у нас изменится, но:

```python
>>> lst
['Москва', 'Уфа', 'Тверь', 'Казань']
>>>
```

список `lst` остаётся без изменений. Это говорит о том, что срез, образовавший новый список `a` совершенно не зависим от начального списка `lst`. Т.е. мы после среза получаем абсолютно новый список.

В срезах не обязательно указывать и начальный, и конечный индекс, можно указать, например только начальный:

```python
>>> lst[2:]
['Тверь', 'Казань']
>>>
```

тогда будут выделены все элементы начиная со 2-го индекса до конца списка.

Можем и наоборот, указать только последний индекс среза:

```python
>>> lst[:3]
['Москва', 'Уфа', 'Тверь']
>>>
```

Соответственно выделяются все элементы от начала списка до 3-го индекса, причём 3-й индекс не включается.

А если не укажем ни первый, ни последний индексы среза:

```python
>>> lst[:]
['Москва', 'Уфа', 'Тверь', 'Казань']
>>>
```

то просто получим копию списка.

Проверим, что это не тот же список, а именно его копия:

```python
>>> cities = lst[:]
>>> cities
['Москва', 'Уфа', 'Тверь', 'Казань']
>>>
```

Мы получили полный список, т.е. переменная `cities` будет ссылаться на точно такой же список, но это уже будет копия списка `lst`.

И убедиться в этом можно так:

```python
>>> id(lst)
140659909083968
>>> id(cities)
140659909116160
>>>
```

и как видите эти значения разные. Т.е. эти переменные ссылаются на разные списки, несмотря на то, что содержимое их совершенно одинаково.

Фактически с помощью такого оператора `lst[:]` создаётся копия списка и это часто используется на практике.

Также копию списка можно создать с помощью функции `list()`:

```python
>>> c = list(lst)
>>> c
['Москва', 'Уфа', 'Тверь', 'Казань']
>>>
```

Как видите, переменная `c` также будет ссылаться на копию списка `lst`.

Какой способ создания копии списка через `[:]` или `list()` решает сам программист, в зависимости от ситуации. Чаще всего конечно используется такой вот синтаксис `[:]`, потому что меньше писать.

А такая операция `d = lst` копию не создаёт, здесь обе переменные и `d` и `lst` будут ссылаться на один и тот же список:

```python
>>> d = lst
>>> id(lst)
140659909083968
>>> id(d)
140659909083968
>>>
```

Эти переменные имеют одинаковый `id`, следовательно ссылаются на один и тот же список.

Это имейте ввиду, что оператор присвоения `=` не создаёт копию списка, а лишь новую переменную, которая ссылается на тот же самый список, что и `lst`.

Так как у списков сосуществуют отрицательные индексы, то их так же можно использовать в срезах. Например, давайте возьмём коллекцию состоящую из оценок студента и возьмём из неё следующие срезы:

```python
>>> marks = [2, 3, 4, 3, 5, 2]
>>> marks[2:-1]
[4, 3, 5]
>>>
```

Мы видим, что здесь, как и в строках, образуется срез от элемента с индексом 2 (включительно) до последнего элемента с индексом -1 (исключая его).

Также мы можем указать оба отрицательных индекса:

```python
>>> marks[-3:-1]
[3, 5]
>>>
```

Дополнительно можно указывать и такой аргумент как шаг перебора элементов, например:

```python
>>> marks[1:5:2]
[3, 3]
>>>
```

Или можем не указывать границу:

```python
>>> marks[:5:2]
[2, 4, 5]
>>>
```

или так:

```python
>>> marks[1::2]
[3, 3, 3]
>>>
```

или вообще не указывать обе границы:

```python
>>> marks[::2]
[2, 4, 5]
>>>
```

Если в качестве шага указать отрицательное значение, то мы будем перебирать элементы списком в обратном порядке, т.е. от последнего элемента до первого:

```python
>>> marks[::-1]
[2, 5, 3, 4, 3, 2]
>>>
```

На выходе у нас получилась инверсия начального списка, т.е все элементы идут в обратном порядке.

Если же укажем шаг `-2`, то:

```python
>>> marks[:: -2]
[2, 3, 3]
>>>
```

мы будем перебирать список в обратном порядке, но уже через один элемент.

Таким образом, механизм срезов списков работает так же, как и со строками.

Но, так как списки относятся к изменяемым типам данных, то с ними, в отличии от строк, можно выполнять одну дополнительную операцию - изменение элемента или группы элементов.

Например, для этого списка `marks` мы заменим два элемента с индексами `2` и `3`, соответственно на строки `"хорошо"` и `"удовлетворительно"`:

```python
>>>  marks[2:4] = ["хорошо", "удовлетворительно"]
>>> marks
[2, 3, 'хорошо', 'удовлетворительно', 5, 2]
>>>
```

Теперь наша коллекция `marks` изменилась. Вы видите как легко и просто это сделать.

Или другой пример. Давайте будем перебирать элементы списка через один и присвоим выбранным элементам значение `0`:

```python
>>> marks[::2] = [0, 0, 0]
>>> marks
[0, 3, 0, 'удовлетворительно', 0, 2]
>>>
```

Теперь все элементы списка `marks`, которые идут через один, стали равны `0`. Правда такая конструкция `marks[::2] = [0, 0, 0]` содержит одну потенциальную ошибку. Так, если число элементов мы увеличим на 1 и повторим эту операцию, то мы получим ошибку:

```python
>>> marks += [3]
>>> marks[::2] = [0, 0, 0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: attempt to assign sequence of size 3 to extended slice of size 4
>>>
```

Потому что данный срез теперь выделяет четыре элемента, а мы ему присваиваем только три, что и приводит к такой ошибке ошибке. Поэтому таких случаях лучше указывать и начальную и конечную границу. В данном случае, если срез начинается с начала строки, то начальную границу можно не указывать, например:

```python
>>> marks[:5:2] = [0, 0, 0]
>>> marks
[0, 3, 0, 'удовлетворительно', 0, 2, 3]
>>>
```

Попробуем сделать так, выделим снова элементы списка `marks` с индексами `2` и `3` и присвоим им новые значения:

```python
>>> marks[2:4] = 10, 20
>>> marks
[0, 3, 10, 20, 0, 2, 3]
>>>
```

Да, так тоже можно делать. И в итоге те значения, которые мы хотели поменять изменились.

Так, через срезы группе элементов можно присваивать определённые значения.

## 3.7.2. Сравнение списков между собой

Предположим у нас есть два списка:

```python
>>> [1, 2, 3] == [1, 2, 3]
True
>>>
```

Да, действительно списками равны.

А если сравним эти списки на неравенство:

```python
>>> [1, 2, 3] != [1, 2, 3]
False
>>>
```

то получим уже `False`.

Так же можем проверить больше или меньше тот или иной список:

```python
>>> [1, 2, 3] > [1, 2, 3]
True
>>>
```

В данном случае - `False`, т.к. списки равны. Но если изменим в первом списке первый элемент:

```python
>>> [10, 2, 3] > [1, 2, 3]
True
>>>
```

то уже увидим значение `True`.

Почему `True`?

Дело в том, что списки сравниваются подобно строкам:

- Сначала мы берём первые элементы и сравниваем, в данном случае `10` больше чем `1`. Поэтому оператор `>` возвращает `True` и дальнейшая проверка последующих элементов не производится.
- В случае, когда среди первых операторов больший во втором списке, то оператор `>` возвращает `False`.
- Когда первые операторы равны, то оператор `>` переходит к сравнению следующих элементов списка и так до тех пор пока не обнаружится неравенство соответствующих элементов.
- Если же все соответствующие элементы равны, то оператор `>` сравнив последние в списках элементы возвращает `False`.

Ну, а если мы в таком случае возьмём оператор `>=`:

```python
>>> [1, 2, 3] >= [1, 2, 3]
True
>>>
```

то получим конечно же `True`.

Если первый список по количеству элементов больше, то оператор `>` также возвращает `True`:

```python
>>> [1, 2, 3, 4] > [1, 2, 3]
True
>>>
```

В данном случае больше тот из списков, в котором большее количество элементов.

Операторы сравнения будут работать и когда списки содержат не только цифровые значения, но и строки:

```python
>>> [1, 2, "abc"] > [1, 2, "abc"]
False
>>>
```

Но если по номеру индекса будет сравниваться число со строкой:

```python
>>> [1, 2, 3] > [1, 2, "abc"]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '>' not supported between instances of 'int' and 'str'
>>>
```

то будет ошибка. Так происходит потому, что Python не умеет сравнивать числа с строками, он может сравнивать только строки со строками и числа с числами. Поэтому и возникает такая ошибка.

Таким образом работают операторы сравнения списков между собой.

На этом мы завершим очередное занятие.

По итогам занятия необходимо знать:

- как выполняются срезы;
- как выполняется сравнение списков между собой.
