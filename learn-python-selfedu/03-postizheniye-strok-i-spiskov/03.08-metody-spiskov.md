# 3.8. Методы списков

Сегодня мы с вами познакомимся с основными методами, которые есть у списков.

Что такое методы вам уже известно, об этом была речь когда мы изучали методы строк - [3.3.1. Что же такое методы?](03.03-osnovnyye-metody-strok.md "3.3.1. Что же такое методы?").

Кратко напомним, что список представляет собой объект и с этим объектом связаны определённые функции, которые и называются его методами.

## 3.8.1. Метод `append()`

**Метод `append()`** - добавляет элемент в конец списка.

Синтаксис:

```python
list.append(elmnt)
```

Обязательный параметр:

`elmnt` - Элемент любого типа (строка, число, объект и т.д.).

Давайте предположим, что у нас есть некий список:

```python
>>> a = [1, -54, 3, 23, 43, -45, 0]
>>>
```

и мы хотим добавить к этому списку ещё одно значение `100` с помощью метода `append()`:

```python
>>> a.append(100)
>>> a
[1, -54, 3, 23, 43, -45, 0, 100]
>>>
```

после вывода списка `a` мы видим, что а конец списка добавилось значение `100`. При этом метод `append()` меняет непосредственно сам список `a`, т.е. чтобы его изменить достаточно вызвать метод `append()` таким образом, как мы сделали выше.

Как видите нам **не надо** присваивать результат какой-либо переменой, например так:

```python
>>> a = a.append(40)
>>>
```

Что же будет, если мы всё же так сделаем? Мы просто потеряем весь список:

```python
>>> a = a.append(40)
>>> print(a)
None
>>>
```

и переменная `a` теперь будет иметь значение `None`.

Что такое значение `None`?

Дело в том, что метод `append()`, в общем-то, ничего не возвращает, он возвращает специальное значение `None`. И когда мы выполнили команду `a = a.append(40)`, то переменная `a` стала ссылаться вместо списка `[1, -54, 3, 23, 43, -45, 0, 100]` на значение `None` и в результате список `[1, -54, 3, 23, 43, -45, 0, 100]` пропал. На него нет уже никаких переменных и его уберёт сборщик мусора.

Поэтому делать так: `a = a.append(40)` нельзя!

Если мы хотим что-то добавить в конец списка, то пишем: `a.append(40)`.

Давайте вернём наш список, который был изначально:

```python
>>> a = [1, -54, 3, 23, 43, -45, 0]
>>> a
[1, -54, 3, 23, 43, -45, 0]
>>>
```

С помощью метода `append()` мы можем добавлять в конец списка самые разные типы данных, например булевы значения:

```python
>>> a.append(True)
>>> a
[1, -54, 3, 23, 43, -45, 0, True]
>>>
```

Или можем добавить вложенный список, например:

```python
>>> a.append([1, 2, 3])
>>> a
[1, -54, 3, 23, 43, -45, 0, True, [1, 2, 3]]
>>>
```

и т.д.

Т.е. мы можем добавлять совершенно разные типы данных, совершенно разные объекты, но только какое-то одно значение, один элемент, добавить больше одного элемента не получится:

```python
>>> a.append(1, 2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: list.append() takes exactly one argument (2 given)
>>>
```

Если мы попытаемся выполнить эту строчку, то получим ошибку.

## 3.8.2. Метод `insert()`

Следующий метод, который мы рассмотрим - `insert()`.

**Метод `insert()`** - позволяет вставлять в список указанный элемент в определённую позицию.

Синтаксис:

```python
list.insert(pos, elmnt)
```

Обязательные параметры:

`pos` - Число, указывающее, в какую позицию вставить значение.

`elmnt` - Элемент любого типа (строка, число, объект и т.д.).

Для примера вставим в позицию под индексом `3` число `-1000`:

```python
>>> a.insert(3, -1000)
>>> a
[1, -54, 3, -1000, 23, 43, -45, 0, True, [1, 2, 3]]
>>>
```

Как видите метод `insert()` вставил в позицию `3` значение `-1000`, а элементы, который занимал позиции с этим индексом и все последующие элементы сдвинул вправо на одну позицию.

Если же нам нужно удалить какой-либо элемент в списке, то для этого существует несколько методов.

## 3.8.2. Метод `remove()`

**Метод `remove()`** - удаляет первое вхождение элемента с указанным значением.

Синтаксис:

```python
list.remove(elmnt)
```

`elmnt` - Элемент любого типа (строка, число, список и т.д.), который вы хотите удалить.

Предположим, что мы хотим удалить в списке `a` элемент со значением `True`:

```python
>>> a.remove(True)
>>> a
[-54, 3, -1000, 23, 43, -45, 0, True, [1, 2, 3]]
>>>
```

После выполнения команды `a.remove(True)`, вы видите, что значение `True` осталось в списке, но была удалена первая единичка.

Почему так получилось?

Дело в том, что булевы значения приводятся к определённым цифровым значениям:

- `True` - `1`;
- `False` - `0`.

На это следует обращать внимание.

Ну, а если мы повторим эту операцию, то:

```python
>>> a.remove(True)
>>> a
[-54, 3, -1000, 23, 43, -45, 0, [1, 2, 3]]
>>>
```

удалится уже значение `True`.

Так можно удалять абсолютно любые элементы в списке по их значению.

А что если попробовать удалить элемент, которого нет в списке?

Например, строку `"hello"`:

```python
>>> a.remove("hello")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: list.remove(x): x not in list
>>>
```

Получаем ошибку.

Т.е. если происходит удаление несуществующего элемента, то метод `remove()` приводит к ошибке.

## 3.8.3. Метод `pop()`

**Метод `pop()`** удаляет элемент в указанной позиции.

Синтаксис:

```python
list.pop(pos)
```

Необязательный параметр:

`pos` - Число, указывающее id элемента, который вы хотите удалить, значение по умолчанию равно `-1`, которое возвращает последний элемент.

Если мы записываем метод `pop()` без аргумента, то он удаляет последний элемент из списка, при этом метод `pop()` возвращает удаленный элемент:

```python
>>> a.pop()
[1, 2, 3]
>>> a
[-54, 3, -1000, 23, 43, -45, 0]
>>>
```

Т.е. мы можем сделать, например, так:

```python
>>> end = a.pop()
>>> a
[-54, 3, -1000, 23, 43, -45]
>>> end
0
>>>
```

Так мы можем использовать удалённый из списка элемент в дальнейшем в нашей программе.

С помощью метода `pop()` не только последний элемент, вообще любой элемент по его индексу.

Например:

```python
>>> a.pop(3)
23
>>> a
[-54, 3, -1000, 43, -45]
>>>
```

В данном случае, метод `pop()` вернул значение элемента с индексом `3` - `23`. А так же удалил это значение из списка.

Т.е. таким образом, с помощью метода `pop()` мы можем удалять либо последние элементы из списка, если не указывать никакие аргументы, либо определённый элемент по его индексу.

## 3.8.4. Метод `clear()`

**Метод `clear()`** - удаляет все элементы из списка.

Синтаксис:

```python
list.clear()
```

Не имеет параметров.

Для полного очищения списка используется метод `clear()`:

```python
>>> a.clear()
>>> a
[]
>>>
```

Как вы видите список `a` пуст, т.е. метод `clear()` удалил из него все элементы.

Вернём наш список:

```python
>>> a = [1, -54, 3, 23, 43, -45, 0]
>>> a
[1, -54, 3, 23, 43, -45, 0]
>>>
```

и поговорим о следующем методе.

## 3.8.5. Метод `copy()`

**Метод `copy()`** - возвращает копию указанного списка.

Синтаксис:

```python
list.copy()
```

Не имеет параметров.

Этот метод помогает создать копию списка, например:

```python
>>> a.copy()
[1, -54, 3, 23, 43, -45, 0]
>>>
```

Значение возвращаемое методом `copy()` можно присвоить переменной и тогда мы получим копию списка:

```python
>>> с = a.copy()
>>> a
[1, -54, 3, 23, 43, -45, 0]
>>> с
[1, -54, 3, 23, 43, -45, 0]
>>>
```

Заметьте, что переменная `с` будет ссылаться уже на другой объект, но его значение будет таким же как и у списка `a`.

Проверим это при помощи функции `id()`:

```python
>>> id(a)
140616602239232
>>> id(с)
140616602221568
>>>
```

Разные идентификаторы говорят о том, что это действительно разные объекты.

Кстати запись `с = a.copy()` эквивалентна следующим записям:

- `c = a[:]`;
- `c = list(a)`.

Как создавать копию списка вы решаете самостоятельно. Какой подход вам больше нравится, тот и используйте. Но, вообще, чаще всего используются срезы - `c = a[:]`, т.к. это самая короткая форма записи.

## 3.8.6. Метод `count()`

**Метод `count()`** - возвращает количество элементов с указанным значением.

Синтаксис:

```python
list.count(value)
```

Обязательный параметр:

`value` - Любой тип (строка, число, список, кортеж и т.д.). Значение для поиска.

Метод `count()` позволяет посчитать количество элементов с указанным значением. Узнаем сколько элементов со значением `1` в списке `с`:

```python
>>> c.count(1)
1
>>>
```

всего одно значение.

Добавим в конец списка единичку и посчитаем ещё раз:

```python
>>> c.append(1)
>>> c
[1, -54, 3, 23, 43, -45, 0, 1]
>>> c.count(1)
2
>>>
```

мы получили значение `2`, т.к. в списке `c` теперь две единички.

Если же мы попытаемся посчитать не существующий элемент в списке:

```python
>>> c.count("hello")
0
>>>
```

то получим результат `0`.

Так работает этот метод.

## 3.8.7. Метод `index()`

**Метод `index()`** - возвращает позицию при первом появлении указанного значения.

Синтаксис:

```python
list.index(elmnt, start)
```

Обязательный параметр:

`elmnt` - Любой тип (строка, число, список и т.д.). Значение для поиска.

`start` - Стартовый индекс позиции с которой мы начинаем поиск.

Метод `index()` позволяет получать первый индекс указанного значения, например:

```python
>>> c.index(1)
0
>>>
```

получили `0`, индекс первой единички в списке `c`. Т.е. метод `index()` возвращает индекс первого найденного значения.

Если мы напишем:

```python
>>> c.index(-54)
1
>>>
```

потому что это следующее значение.

А вот, что нам делать если нужно найти индекс последней единички?

Для этой задачи нам потребуется второй параметр `start`, например:

```python
>>> c.index(1, 2)
7
>>>
```

Так мы получили позицию `7`, потому что мы начинаем поиск со второй позиции списка и следующая единичка находится на последней седьмой позиции.

Если же этому методу указать не существующее значение, то он возвращает ошибку:

```python
>>> c.index("hello")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 'hello' is not in list
>>>
```

Чтобы в программах избежать такой ситуации нужно проверить наличие значения в списке. Это делается при помощи специального оператора `in`:

```python
>>> "hello" in c
False
>>>
```

В нашем случае оператор `in` вернёт `False`, т.к. значение `hello` отсутствует в списке. И если мы получаем `False`, то выполнять подобную операцию `c.index("hello")` не нужно. Как это сделать в программе мы рассмотрим на следующих занятиях когда будем проходить операторы ветвления, т.е. операторы проверки условий. А пока просто имейте в виду, что для избежания полученной нами выше ошибки необходимо проверить, существует ли соответствующее значение в списке.

## 3.8.8. Метод `reverse()`

Метод `reverse()` - меняет порядок сортировки элементов на обратный.

Синтаксис:

```python
list.reverse()
```

Не имеет параметров.

При помощи метода `reverse()` мы можем менять порядок следования элементов на обратный:

```python
>>> c.reverse()
>>> c
[1, 0, -45, 43, 23, 3, -54, 1]
>>>
```

## 3.8.9. Метод `sort()`

Метод `sort()` - сортирует список по возрастанию.

Вы также можете создать функцию для определения критериев сортировки.

Синтаксис:

```python
list.sort(reverse=True|False, key=myFunc)
```

Необязательные параметры:

`reverse` - Переворачивает порядок сортировки. `reverse=True` сортирует список по убыванию. По умолчанию `reverse=False`.

`key` - Функция для указания критериев сортировки.

Например:

```python
>>> c.sort
>>> c
[-54, -45, 0, 1, 1, 3, 23, 43]
>>>
```

Вы видите, что все элементы списка теперь отсортированы по возрастанию.

Метод `sort()` сортирует исходный список не создавая новый.

Так, например:

```python
>>> a = c.sort()
>>> a
>>>print(a)
None
>>>
```

метод `sort()` ничего не возвращает или возвращает `None`.

Это кардинальное отличие от функции `sorted()`, которую мы с вами рассматривали, которая именно возвращает новый отсортированный список:

```python
>>> sorted(c)
[-54, -45, 0, 1, 1, 3, 23, 43]
>>>
```

при этом прежний список остаётся неизменным.

А метод `sort()` применяется именно к текущему списку и меняет именно этот список, и при этом ничего не возвращает.

Т.е. это **кардинальное отличие метода `sort()` от функции `sorted()`**.

На самом деле ест и другие отличия, о которых мы с вами ещё поговорим.

Если же мы хотим выполнить сортировку по убыванию, то для этого прописывается дополнительный параметр `reverse` и ему присваивается значение `True`:

```python
>>> c.sort(reverse=True)
>>> c
[43, 23, 3, 1, 1, 0, -45, -54]
>>>
```

Теперь с начала идёт максимальное значение, а в конце минимальное.

Сортировку, с помощью метода `sort()`, можно выполнить не только с числовыми значениями, но и с любыми элементами, которые можно сравнивать между собой на больше и меньше, например со строками:

```python
>>> list = ["Москва", "Санкт-Петербург", "Тверь", "Казань"]
>>> list.sort()
>>> list
['Казань', 'Москва', 'Санкт-Петербург', 'Тверь']
>>>
```

Итак, на этом занятии мы с вами рассмотрели основные методы списков и научились ими пользоваться.
