# 3.6. Списки и операции над ними

## 3.6.1. Списки

**Список `list[]`** - упорядоченный изменяемый набор объектов произвольных типов, пронумерованных от 0. Они используются для хранения и работы с данными.

Зачем нужны списки?

Представьте себе, что нам в программе нужно хранить и обрабатывать список городов:

`Города: | Казань | Тверь | Уфа | Астрахань |`

или список оценок студента:

`Оценки: | 4 | 3 | 2 | 2 | 5 | 4 | 5 |`

или список каких-либо булевых значений:

`Булевый: | True | False | False | True |`

или значение функции:

`f() = | 1 | 2 | 3 | 4 | 5 | 6 |`

и многое другое.

Часто, когда нам надо оперировать набором каких-либо данных используются списки. и на этом занятии мы с ними и познакомимся.

Перейдём в консоль Python. И здесь в интерактивном режиме будем изучать как задавать списки и работать с ними. Так будет удобнее.

И так, чтобы задать список используются квадратные скобки и внутри их прописываются какие-либо данные, например, строки:

```python
>>> ["Москва", "Тверь", "Вологда"]
['Москва', 'Тверь', 'Вологда']
>>>
```

Естественно, чтобы оперировать таким списком через переменную, нужно её задать:

```python
>>> marks = [2, 3, 4, 3, 5, 2]
>>>
```

Теперь эта переменная `marks` будет ссылаться на список оценок:

```python
>>> marks
[2, 3, 4, 3, 5, 2]
>>>
```

## 3.6.2. Индексы элементов списка

Давайте теперь рассмотрим, как эту конструкцию, этот список использовать в программировании. Например, вычислить средний балл студента по всем оценкам. Для этого нам нужно уметь обращаться к отдельным элементам этого списка.

Как это сделать?

Т.к. список это упорядоченная коллекция, то у каждого элемента списка есть свой порядковый номер - индекс. И по этому индексу можно обращаться к элементу списка, используя уже известный нам, в принципе, синтаксис:

| Индексы | 0   | 1   | 2   | 3  | 4  | 5  |
|:--------|:---:|:---:|:---:|:--:|:--:|:--:|
| marks = | 2   | 3   | 4   | 3  | 5  | 2  |

После имени списка (переменной содержащей список) ставятся квадратные скобки `[]` и внутри их указываются соответствующие индексы. В нашем случае можно сделать так:

```python
>>> marks[0]
2
>>>
```

Мы вызвали первый элемент списка, т.к. первый элемент списка имеет индекс `0`.

Если мы запишем индекс `1`, то мы получим уже второй элемент списка:

```python
>>> marks[1]
3
>>>
```

и т.д.

Т.е. в нашем случае, если нам надо посчитать средний балл студента, мы могли бы записать общую формулу таким образом:

```python
>>> (marks[0] + marks[1] + marks[2] + marks[3] + marks[4] + marks[5]) / 6
3.1666666666666665
>>>
```

Здесь всё очевидно, шесть оценок студента мы складываем и делим на 6 и в итоге получаем средний балл.

Это простейший пример того как можно хранить данные в списке и использовать их.

Причём индексирование здесь работает так же, как и со строками. Так, если мы укажем не существующий индекс, например `10`:

```python
>>> marks[10]
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>>
```

то получим ошибку.

А чтобы обратиться к последнему элементу списка используется отрицательный индекс `-1`:

```python
>>> marks[-1]
2
>>>
```

Мы получили `2`, что и является последним элементом списка.

Т.е. у списков есть и отрицательные индексы, которые перебирают индексы с конца до начала списка:

| Индексы          | 0   | 1   | 2   | 3  | 4  | 5  |
|:-----------------|:---:|:---:|:---:|:--:|:--:|:--:|
| marks =          | 2   | 3   | 4   | 3  | 5  | 2  |
| Обратные индексы | -6  | -5  | -4  | -3 | -2 | -1 |

Т.е. с индексами всё как в строках.

Но в отличии от строк, списки относятся к изменяемым типам данных. Т.е. мы можем изменить ранее хранимые в списке значения.

Например, студент исправил свою первую двойку на тройку. Тогда мы можем изменить значение в списке под индексом `0` следующим образом:

```python
>>> marks[0] = 3
>>>
```

Тогда наш список изменится:

```python
>>> marks
[3, 3, 4, 3, 5, 2]
>>>
```

Как вы помните, такая операция со строками приводит к ошибке, т.к. строки - неизменяемый тип данных. А вот со списками мы так делать можем и в этом их кардинальное отличие от строк.

Список это динамическая структура данных, которая может изменяться во время выполнения программы.

**Список - изменяемый тип данных**. Это нужно запомнить.

## 3.6.3. Типы данных в списках

Мало того списку состоящему целиком, например, из целых чисел мы можем легко присвоить любой другой тип данных. Например:

```python
>>> marks[1] = "удовлетворительно"
>>> marks
[3, "удовлетворительно", 4, 3, 5, 2]
>>>
```

Теперь наш список будет состоять из чисел и одной строки.

Вообще списки могут содержать самые разные типы данных. Например:

```python
>>> lst = ["Москва", 1320, 5.8, True, "Тверь", False]
>>> lst
['Москва', 1320, 5.8, True, 'Тверь', False]
>>>
```

Как видите в строке `lst` у нас соседствуют и строки, и целые числа, и вещественные числа, и булевы значения... В списки можно помещать даже списки:

```python
>>> lst2 = [1, 2.5, [-1, -2, -3], 4, 5]
>>> lst2
[1, 2.5, [-1, -2, -3], 4, 5]
>>>
```

Мы видим, что переменная `lst2` ссылается на список, внутри которого есть ещё один вложенный список. О вложенных списках мы ещё будем с вами говорить, а пока просто имейте в виду, что такой функционал тоже возможен.

Т.е. элементами списка могут быть любые объекты языка Python или, по другому, любые типы данных.

Если нам нужно создать пустой список, то мы можем сделать так:

```python
>>> a = []
a
>>> a
[]
>>>
```

или с помощью функции `list()`.

## 3.6.4. Функция `list()`

**Функция `list()`** - это функция, которая возвращает соответствующий список.

```python
>>> b = list()
>>> b
[]
>>>
```

Функция `list()` без аргументов создает пустой список.

Если же в этой функции как аргумент указать какой-либо список:

```python
>>> b = list([True, False])
>>> b
[True, False]
>>>
```

то у нас на выходе получится новый список. Переменная `b` будет ссылаться на новый список, совершенно не зависимый от того что мы передали в качестве аргумента функции `list()`. Т.е. с помощью функции `list()` мы можем создавать копии списков.

Или мы можем в функцию `list()` передать строку. Например:

```python
>>> list("python")
['p', 'y', 't', 'h', 'o', 'n']
>>>
```

На выходе мы получим список состоящий из отдельных символов этой строки.

Т.е. функция `list()` на основе любого перебираемого объекта, объекта у которого можно перебирать все его элементы формирует список.

Такие перебираемые объекты в языке Python ещё называются **итерируемыми объектами**. О них мы также будем говорить на будущих занятиях. Сейчас важно понимать, что функция `list()`  может создавать списки, не только на основе уже существующих списков, но и на основе любых других перебираемых (итерируемых) объектов.

## 3.6.5. Встроенные функции Python для работы со списками

В Python есть несколько встроенных функций, которые могут быть полезными при работе с списками:

- `len()` - определение числа элементов в списке (длина списка);
- `max()` - определение максимального значения;
- `min()` - определение минимального значения;
- `sum()` - определение суммы всех элементов списка;
- `sorted()` - сортировка коллекции;

Давайте рассмотрим их подробнее.

### 3.6.5.1. Функция `len()`

**Функция `len()`** - функция, которая определяет число элементов в списке.

Синтаксис:

```python
len(object)
```

Обязательный параметр:

`object` - Объект, состоящий из последовательности или коллекции.

Пример:

```python
>>> marks
[3, 'удовлетворительно', 4, 3, 5, 2]
>>>
```

Наш список `marks` состоит из шести элементов поэтому функция `len(marks)`:

```python
>>> len(marks)
6
>>>
```

вернёт значение `6`.

Соответственно если мы передадим на вход функцию `len()` пустой список:

```python
>>> len([])
0
>>>
```

То мы получим - `0`.

### 3.6.5.2. Функции `min()` и `max()`

**Функции `min()` и `max()`** - функции, которые определяют минимальное и максимальное значения элементов.

Синтаксис функций `min()` и `max()`:

```python
min(n1, n2, n3, ...)

или

min(iterable)
```

Параметры функций `min()` и `max()`:

`n1, n2, n3, ...` - Один или несколько элементов для сравнения.

или

`iterable` - Итерируемый объект с одним или несколькими элементами для сравнения.

Давайте мы создадим новый список, значения температуры по дням города Москвы:

```python
>>> t = [23.5, 25.6, 27.3, 26.0, 30.4, 29.5]
>>> t
[23.5, 25.6, 27.3, 26.0, 30.4, 29.5]
>>>
```

Допустим, у нас такой список температур и мы хотим найти минимальное и максимальное значения:

```python
>>> min(t)
23.5
>>> max(t)
30.4
>>>
```

Действительно, `23.5` - минимальное значение в списке, а `30.4` - максимальное.

### 3.6.5.3. Функция `sum()`

**Функция `sum()`** - функция, возвращает сумму всех элементов в итерируемом объекте.

Синтаксис:

```python
sum(iterable, start)
```

Обязательный параметр:

`iterable` - Последовательность для суммирования.

Необязательный параметр:

`start` - Начальное значение суммирования.

Пример:

```python
>>> sum(t)
162.3
>>>
```

На выходе мы получили общую сумму всех элементов в списке.

Теперь мы можем определить среднюю температуру гораздо проще. Достаточно использовать две функции `sum()` и `len()`:

```python
>>> sum(t) / len(t)
27.05
>>>
```

Видите как это легко и просто делается на уровне функций.

### 3.6.5.4. Функция `sorted()`

Функция `sorted()` - возвращает отсортированный список указанного итерируемого объекта.

Вы можете указать восходящий или нисходящий порядок. Строки сортируются по алфавиту, а числа сортируются по номерам.

Примечание. Вы не можете сортировать список, который содержит и строковые значения, и числовые значения.

Синтаксис:

```python
sorted(iterable, key=key, reverse=reverse)
```

Обязательный параметр:

`iterable` - Итерируемый объект.

Необязательные параметры:

`key` - Функция, которую нужно выполнить, чтобы определить порядок. По умолчанию `None`.

`reverse` - Порядок сортировки. Логическое значение. `False` сортирует по возрастанию, `True` сортирует по убыванию. Значение по умолчанию — `False`.

Пример:

```python
>>> sorted(t)
[23.5, 25.6, 26.0, 27.3, 29.5, 30.4]
>>>
```

Причём, функция `sorted()` возвращает новый отсортированный список. Т.е. исходный список не меняется:

```python
>>> t
[23.5, 25.6, 27.3, 26.0, 30.4, 29.5]
>>>
```

А для сохранения нового отсортированного списка необходимо его значение присвоить какой-либо переменной, например:

```python
>>> t_sort = sorted(t)
>>> t_sort
[23.5, 25.6, 26.0, 27.3, 29.5, 30.4]
>>>
```

Теперь переменная `t_sort` будет ссылаться на новый отсортированный список, а переменная `t` - на исходный.

Мы рассмотрели сортировку по возрастанию. А что если нам надо отсортировать список по убыванию? Для этого у функции `sorted()` есть аргумент `reverse` и ему надо присвоить значение `True`:

```python
>>> t_sort = sorted(t, reverse=True)
>>> t_sort
[30.4, 29.5, 27.3, 26.0, 25.6, 23.5]
>>>
```

Мы видим, что сначала идёт максимальное значение, а остальные значения отсортированы по убыванию. Т.е. мы сделали обратную (реверсную) сортировку.

Необходимо также отметить, что эти три функции:

- `max()`;
- `min()`;
- `sorted()`;

работают не только с числовыми значениями, но и с любыми типами данных, в которых допустимо сравнение на большее `>` и меньшее `<`. Например со строками.

Убедимся в этом. Создадим список состоящий из символов:

```python
>>> s = list("python")
>>> s
['p', 'y', 't', 'h', 'o', 'n']
>>>
```

и найдём максимальное значение:

```python
>>> max(s)
'y'
>>>
```

На выход емы получаем `'y'`, т.к. именно этот символ имеет наибольший код в кодовой таблице символов.

Если взять функцию `min()`:

```python
>>> min(s)
'h'
>>>
```

соответственно получим символ с наименьшим кодом `'h'`.

Также можем и отсортировать этот список:

```python
>>> sorted(s)
['h', 'n', 'o', 'p', 't', 'y']
>>>
```

и на выходе получим такой отсортированный список.

Т.е. мы убедились, что функции `max()`, `min()` и `sorted()` работают со всеми типами данных, которые можно сравнивать на больше и меньше.

А вот функция `sum()` уже работать не будет:

```python
>>> sum(s)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'
>>>
```

т.к. суммирование выполняется только с числовыми значениями.

## 3.6.6. Встроенные функции Python для работы со списками

Далее мы рассмотрим набор операторов для работы со списками:

- `+` - объединение двух списков в один;
- `*` - дублирование списка;
- `in` - проверка наличия элемента в списке.
- `del` - удаление элемента из списка.

## 3.6.6.1. Оператор объединения двух списков `+`

**Оператор `+`** - объединение двух списков.

Пример:

```python
>>> [1, 2, 3] + [4, 5]
[1, 2, 3, 4, 5]
>>>
```

На выходе формируется новый список, состоящий из элементов первого и второго списка. Т.е. объединяются два списка в один.

Но обратите внимание, что если с м ы список попытаемся объединить, например с просто числом:

```python
>>> [1, 2, 3] + 4
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "int") to list
>>>
```

то получим ошибку. Т.к. справа и слева от оператора должны быть именно списки.

Поэтому четвёрку нужно записать тоже в виде списка:

```python
>>> [1, 2, 3] + [4]
[1, 2, 3, 4]
>>>
```

Теперь никаких ошибок нет.

Также можно сделать так:

```python
>>> [1, 2, 3] + [True]
[1, 2, 3, True]
>>>
```

У нас получился список, где есть числа и булевы значения. Т.е список может содержать разные типы данных, поэтому объединять можно списки с разными типами данных.

### 3.6.6.2. Оператор `*`

**Оператор `*`** - оператор дублирования списка.

Предположим, у нас есть список и нам надо продублировать его три раза. Для этого после нашего списка добавляем оператор `*` и число, соответствующее количеству раз которое нужно дублировать:

```python
>>> ["Я", "люблю", "Python"] * 3
['Я', 'люблю', 'Python', 'Я', 'люблю', 'Python', 'Я', 'люблю', 'Python']
>>>
```

Необходимо помнить, что число дублирований обязательно должно быть ценным числом либо переменной ссылающейся на целое число. использовать дробное число нельзя, будет ошибка:

```python
>>> ["Я", "люблю", "Python"] * 3.5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'float'
>>>
```

На практике можно комбинировать операторы и строить такие, например, конструкторы:

```python
>>> ["Я"] + ["люблю"] * 3 + ["Python"]
['Я', 'люблю', 'люблю', 'люблю', 'Python']
>>>
```

Как видите всё выглядит достаточно очевидно, гибкоЮ наглядно и просто. Этим и знаменателен этот язык, в нём многое реализуется простыми и понятными методами в отличии от других языков программирования.

### 3.6.6.3. Оператор `in`

**Оператор `in`** - проверка наличия элемента в списке.

Реализуется он следующим образом.

Предположим, что у нас есть такой список с самыми разными значениями:

```python
>>> lst = ["Москва", 1320, 5.8, True, "Тверь", False]
>>>
```

и мы хотим узнать, входит ли в список такое целое значение `1320`:

```python
>>> 1320 in lst
True
>>>
```

На выходе получаем `True`, потому что такое значение есть в списке.

А если напишем не существующее значение, то получим `False`:

```python
>>> 120 in lst
False
>>>
```

Можем проверить и входит ли один список в другой:

```python
>>> [1, 2] in lst
False
>>>
```

В данном случае мы получили `False`, но если мы добавим список `[1, 2]` в список `lst`, то получим `True`:

```python
>>> lst = ["Москва", 1320, 5.8, True, "Тверь", False, [1, 2]]
>>> [1, 2] in lst
True
>>>
```

И так можно работать со всеми типами данных.

Например со строками:

```python
>>> "Москва" in lst
True
>>>
```

Да, в данном случае входит.

### 3.6.6.4. Оператор `del`

**Оператор `del`** - удаление элемента по его индексу из списка.

Например, мы хотим из списка `lst` удалить элемент `5.8`. У него индекс равен `2`, поэтому:

```python
>>> lst = ["Москва", 1320, 5.8, True, "Тверь", False, [1, 2]]
>>> del lst[2]
>>> lst
['Москва', 1320, True, 'Тверь', False, [1, 2]]
>>>
```

В итоге список `lst` не будет содержать элемента `5.8`.

Так при помощи оператора `del` можно удалять отдельные элементы из списка.

Причём элементы в новой строке будут проиндексированы заново и будут идти по порядку.

На этом завершим наше первое занятие по спискам. Из него вы должны чётко представлять:

- как задавать списки при помощи квадратных скобок `[]` и функции `list()`;
- понимать механизм обращения к отдельным элементам списка по индексам положительным и отрицательным;
- уметь использовать функции: `len()`, `max()`, `min()`, `sum()` и `sorted()`;
- уметь использовать набор операторов: `+`, `*`, `in`, `del`;
