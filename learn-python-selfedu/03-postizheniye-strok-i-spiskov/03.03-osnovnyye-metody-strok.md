# 3.3. Основные методы строк

На этом занятии мы познакомимся с основными методами строк.

## 3.3.1. Что же такое методы?

Что же такое методы?

Когда мы объявляем какую-либо строковую переменную `s = "python"`, то у нас в памяти ПК автоматически создаётся объект содержащий набор символов `python`.

Т.е. у нас теперь есть объект и на этот объект ссылается переменная `s`, причём тип этого объекта будет строковый. И мы легко можем в этом убедиться:

```python
>>> s = "python"
>>> type(s)
<class 'str'>
```

Так вот, каждый такой объект связан с набором стандартных функций для работы с строками и эти функции называются **методами**.

Чтобы вызвать какой-либо метод необходимо использовать следующий синтаксис:

```python
объект.метод(аргументы)
```

В начале мы указываем объект для которого мы вызываем метод. Объектом может быть либо непосредственно строка, либо переменная ссылающаяся на строку.

Далее ставим точку и после точки записываем название метода, т.е. название одной из стандартных функций, входящих в набор для работы со строками.

А далее в круглых скобках - список аргументов, если он необходим.

Теперь рассмотрим всё это на конкретных примерах.

Создадим файл `03.03.01.py` с таким содержанием:

```python
s = "python"
```

Ниже в этом же файле запишем нашу переменную `s` и поставим точку:

```python
s = "python"
s.
```

И сразу же появится всплывающая подсказка с перечнем доступных методов.

Некоторые из них мы с вами рассмотрим, наиболее часто используемые. Остальные используются по аналогии.

Снова перейдём в консоль Python.

## 3.3.2. Метод `upper()`

Первый метод который мы рассмотрим - `upper`.

**Метод `upper()`** - переводит строку в верхний регистр:

```python
s = "python"
s.upper()
'PYTHON'
>>>
```

Обратите внимание, что вызов метода записывается с круглыми скобками после его названия.

Т.е. изначально строка состояла из строчных букв, а на выходе мы получили новую строку, которая состоит только из заглавных букв. СТрока же `s` не изменится, т.к. строки принадлежат к неизменяемым типам данных.

Если мы хотим результат работы метода сохранить, то его следует присвоить какой-либо переменной:

```python
>>> res = s.upper()
>>> res
'PYTHON'
```

В результате у нас переменная `res` будет ссылаться на новую строку `PYTHON`.

Таким образом происходит работа со всеми методами.

## 3.3.3. Метод `lower()`

Второй метод который мы рассмотрим выполняет противоположенную операцию.

**Метод `lower()`** - переводит строку в нижний регистр.

Пример:

```python
>>> res.lower()
'python'
>>>
```

Как видите изначально переменная `res` ссылается на строку `PYTHON`, а возвращает уже строку `python`.

## 3.3.4. Метод `count()`

Следующий метод у нас `count()`.

**Метод `count()`** - возвращает количество вхождений подстроки в строку.

Метод `count()` имеет один обязательный и два необязательных аргумента:

```python
string.count(value, start, end)
```

Обязательный аргумент:

- `value` - подстрока, которую нужно найти.

Без него метод count() выдаст ошибку, т.к нечего искать.

Не обязательные аргументы:

- `start` - индекс с которого начинается поиск.
- `end` - индекс, которым заканчивается поиск.

Эти параметры при необходимости можно указывать, но если потребности в них нет, то без них метод будет работать корректно.

Посмотрим на примере как всё это работает.

Зададим такую строку:

```python
>>> msg = "abrakadabra"
```

и при помощи метода `count()` посчитаем количество вхождений подстроки `ra`:

```python
>>> msg.count("ra")
2
>>>
```

На выходе мы видим значение `2`. И действительно подстрока `ra` у нас встречается дважды.

Давайте осуществим подсчёт количество вхождений подстроки не во всей строке, а с символа с индексом `4`:

```python
>>> msg.count("ra", 4)
1
>>>
```

и на выходе уже имеем всего одно вхождение.

Если же указать не только начальный индекс, а и конечный, например, `10`, то получим:

```python
>>> msg.count("ra", 4, 10)
0
>>>
```

Так получилось, потому что символ под индексом `10` не участвует в поиске. Т.е. в таком случае метод просматривает часть строки от индекса `4` включительно до индекса `10` исключая его. Если же бы мы хотели проверить до конца строки, то мы должны были бы указать `11`:

```python
>>> msg.count("ra", 4, 11)
1
>>>
```

## 3.3.5. Метод `find()`

**Метод `find()`** - возвращает индекс первого найденного вхождения подстроки в строку. Аргументы `value`, `start` и `end` работают также как и в методе count:

```python
string.find(value, start, end)
```

Посмотрим как работает этот метод на примере:

```python
>>> msg.find("br")
1
>>>
```

действительно если мы отобразим нашу строку:

```python
>>> msg
'abrakadabra'
>>>
```

то увидим, что первое вхождение подстроки `br` имеет индекс `1`.

А теперь начнём поиск со стартового индекса `2`:

```python
>>> msg.find("br", 2)
8
>>>
```

теперь метод `find()` возвращает `8`.

И действительно следующее вхождение подстроки `br` имеет индекс равный  `8`.

А если метод `find()` не находит подстроку, то он возвращает всегда `-1`:

```python
>>> msg.find("brr")
-1
>>>
```

Аргумент `end` работает так же как и в методе `count`.

Метод `find` осуществляет поиск от начала до конца, но что же делать, если нам нужно искать с конца?

для этого существует другой метод `rfind()`.

## 3.3.6. Метод `rfind()`

**Метод `rfind()`** - возвращает индекс последнего найденного вхождения подстроки в строку. Аргументы `value`, `start` и `end` работают также как и в методе count:

```python
string.find(value, start, end)
```

Метод `rfind()` работает абсолютно так же как и метод `find()`, с той лишь разницей, что производит поиск с конца строки.

Например, если мы снова в нашей строке выполним поиск подстроки `br`, но будем использовать метод `rfind()`, то получим:

```python
>>> msg.rfind("br")
8
>>>
```

т.е. поиск первого вхождения подстроки производится с конца строки.

## 3.3.7. Метод `index()`

**Метод `index()`** - возвращает индекс первого найденного вхождения подстроки в строку. Аргументы `value`, `start` и `end` работают также как и в методе count:

string.index(value, start, end)

Он работает абсолютно так же как и метод `find()`, с той лишь разницей, что метод `find()` возвращает -1, если значение не найдено, а метод `index()` вызывает ошибку.

Рассмотрим разницу на примере:

```python
>>> msg.index("brr")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found
>>>
```

Как видите в отличии от метода `find()`, метод `index()` вызывает ошибку если значение не найдено.

Зачем же нужен такой метод? Когда при использовании метода `find()` никаких ошибок нет, а с `-1` можно работать дальше.

Но в действительности такие ошибки можно обрабатывать как исключения. Это бывает полезный для сохранения общей архитектуры программы, когда неожиданные ситуации обрабатывается единым образом. Но обо всё этом речь пойдёт позже.

Следующий метод `replace()`.

## 3.3.8. Метод `replace()`

**Метод `replace()`** - заменяет указанную фразу другой указанной фразой.

Синтаксис:

```python
string.replace(oldvalue, newvalue, count)
```

Т.е. этот метод выполняет замену подстроки `oldvalue` на `newvalue` с количеством вхождений `count`.

Например мы можем в нашей строке `abrakadabra` заменить подстроку все буквы `a` на буквы `o`:

```python
>>> msg.replace("a", "o")
'obrokodobro'
>>>
```

в результате получаем новую строку `obrokodobro`.

Или такой пример. Заменим все буквы `ab` на `AB`:

```python
>>> msg.replace("ab", "AB")
'ABrakadABra'
>>>
```

Получится такая строка `ABrakadABra`.

Или можно удалить из строки подстроку `ab`, для этого её нужно заменить на пустую подстроку `""`:

```python
>>> msg.replace("ab", "")
'rakadra'
>>>
```

Также у метода `replace()` есть третий необязательный параметр **`count`**. Он определяет количество замен:

```python
>>> msg.replace("a", "o", 2)
'obrokadabra'
>>>
```

вы видите, что были заменены только первые два символа, а остальные `а` останутся без изменений.

## 3.3.9. Метод `isalpha()`

**Метод `isalpha()`** - возвращает значение `True`, если все символы являются буквами алфавита.

Пример использования:

```python
>>> msg.isalpha()
True
>>>
```

Метод вернул `True`.

Если же сделать так:

```python
>>> "hello world".isalpha()
False
>>>
```

потому что строка `hello world` не состоит целиком из букв, она содержит и пробел.

## 3.3.10. Метод `isditgit()`

**Метод `isditgit()`** - возвращает True, если все символы являются цифрами, иначе False. Показатель степени, например $x^2$, также считается цифрой.

Например, если мы возьмём строку `5.6`:

```python
>>> "5.6".isdigit()
False
>>>
```

Получим `False`, потому что здесь кроме цифр присутствует символ `.`.

Если же мы уберём эту точку:

```python
>>>  "56".isdigit()
True
>>>
```

то соответственно получим `True`.

Попробуем с отрицательным числом:

```python
>>> "-56".isdigit()
False
>>>
```

получаем `False`, т.к. символ `-` не является цифровым значением.

Таким образом, если строка состоит только из цифр, то метод `isditgit()` вернёт `True` и `False` в противном случае.

## 3.3.11. Метод `rjust()`

**Метод `rjust()`** - выравнивает строку по правому краю, используя указанный символ (пробел по умолчанию) в качестве символа заполнения.

Синтаксис:

```python
string.rjust(length, character)
```

Обязательный параметр:

**`length`** - Длина возвращаемой строки.

Не обязательный параметр:

**`character`** - Символ для заполнения пропущенного места (слева от строки). По умолчанию " " (пробел).

Рассмотрим работу метода `rjust()` на примере.

Объявим строковую переменную `d`:

```python
>>> d = "abc"
>>>
```

Теперь для этой строки вызовем метод `rjust()`:

```python
>>> d.rjust(5)
'  abc'
>>>
```

На выходе получим новую строку `'  abc'` в которой слева будет добавлено два пробела и в итоге вся строка будет состоять из пяти символов. Т.е. этот метод, в данном случае, для выравнивания строки до 5-ти символов добавил слева два пробела.

Метод `rjust()` часто используется для добавления незначащих нулей перед цифрами.

Например, если мы зададим строку `d = "12"` и вызовем для неё метод `rjust()` со следующими параметрами:

```python
>>> d = "12"
>>> d.rjust(4, "0")
'0012'
>>>
```

то на выходе получим строку `0012`, где сначала идёт два незначащих нуля, а затем `12`.

Необходимо запомнить, что вторым параметром всегда нужно указывать только один символ.

Если мы укажем, например, два символа:

```python
>>> d.rjust(4, "00")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: The fill character must be exactly one character long
>>>
```

получим ошибку.

Всегда следует указывать только один символ.

Если же мы укажем длину строки меньше чем в исходной:

```python
>>> d.rjust(1, "0")
'12'
>>>
```

на выходе будет новая строка с тем же значением, в нашем случае `12`.

## 3.3.12. Метод `ljust()`

**Метод `ljust()`** - Метод ljust() выровняет строку по левому краю, используя указанный символ (пробел по умолчанию) в качестве символа заполнения.

Синтаксис:

```python
string.ljust(length, character)
```

Обязательный параметр:

**`length`** - Длина возвращаемой строки.

Не обязательный параметр:

**`character`** - Символ для заполнения пропущенного места (слева от строки). По умолчанию " " (пробел).

Работает метод `ljust()` точно так же как и метод `rjust()`, только добавляет символы справа.

Например:

```python
>>> d.ljust(10, "*")
'12********'
>>>
```

## 3.3.13. Метод `split()`

**Метод `split()`** - возвращает коллекцию строк, на которые разбивается исходная строка. Разбивка осуществляется по указанному разделителю (сепаратору).

Синтаксис:

```python
string.split(separator, maxsplit)
```

Не обязательные параметры:

**`separator`** - Указывает разделитель, используемый при разделении строки. По умолчанию разделителем является пробел.

**`maxsplit`** - Определяет, сколько разбиений нужно сделать. Значение по умолчанию — -1, что означает «все вхождения».

Например:

```python
>>> "Иванов Иван Иванович".split(" ")
['Иванов', 'Иван', 'Иванович']
>>>
```

На выходе получаем три строки. Т.е. у нас вся строка была разбита по разделителю пробелу на три строки и мы получили список из строк. А что такое списки и как с ними работать мы рассмотрим позже. Пока просто имей те в виду, что на выходе мы получили список из строк.

Рассмотрим конкретный пример где используется метод `split()`.

Допустим у нас есть строка в которой цифры записаны через запятую и после запятой пробел либо может стоять, либо может не стоять, могут стоять два пробела:

```python
>>> digs = "1, 2,3, 4,  5,6"
>>> 
```

и мы хотели бы выделить из этой строки все цифры без каких-либо пробелов. Сделать это можно следующим образом:

```python
>>> digs.replace(" ", "").split(",")
['1', '2', '3', '4', '5', '6']
>>>
```

Сначала мы к строке `digs` применим метод `replace()` для удаления всех пробелов и так как на выходе этого метода будет строка, то мы можем применить к ней метод `split()`. и с помощью него разбить строку уже без пробелов `"1,2,3,4,5,6"` по запятым.

В общем у нас на выходе получился список строк, каждая из состоит из отдельной цифры.

Здесь мы также рассмотрели как можно последовательно вызывать методы. И как видите это очень удобно.

## 3.3.14. Метод `join()`

**Метод `join()`** - берёт все элементы из итерируемого объекта и объединяет их в одну строку. В качестве string должен быть указан разделитель.

Синтаксис:

```python
string.join(iterable)
```

Обязательный аргумент:

**`iterable`** - Любой итерируемый объект, все возвращаемые значения которого являются строками.

Давайте снова посмотрим на конкретном примере как работает метод `join()`.

Присвоим переменной `d` следующее значение:

```python
>>> d = digs.replace(" ", "").split(",")
>>>
```

т.е. `d` ссылается на такой список `['1', '2', '3', '4', '5', '6']` и используем этот список мы создадим новую строку:

```python
>>> ", ".join(d)
'1, 2, 3, 4, 5, 6'
>>>
```

На выходе мы получили строку `'1, 2, 3, 4, 5, 6'`. Именно такая строка у нас получилась, потому что как разделитель мы указали `", "`.

Другой пример. Создадим переменную `fio`:

```python
>>> fio = "Иванов Иван Иванович"
```

И допустим, что мы хотели бы, чтобы все слова в нашей строке были разделены запятыми:

```python
>>> ", ".join(fio.split())
'Иванов, Иван, Иванович'
>>>
```

На выходе мы получаем новую строку, где все подстроки, т.е. фамилия, имя и отчество, разделены запятыми.

## 3.3.15. Метод `strip()`

**Метод `strip()`** - удаляет в начале и в конце строки все символы пробелов и переноса строк или указанные в аргументе символы.

Синтаксис:

```python
string.strip(characters)
```

Не обязательный параметр:

**`characters`** - Символы, которые нужно удалить.

Рассмотрим на примере работу метода `strip()`.

Применим метод `strip()` к следующей строке:

```python
>>> "    hello world       \n".strip()
'hello world'
>>>
```

## 3.3.16. Метод `rstrip()`

**Метод `rstrip()`** - удаляет в конце строки (справа) все символы пробелов и переноса строк или указанные в аргументе символы.

```python
>>> "    hello world       \n".rstrip()
'    hello world'
>>>
```

## 3.3.17. Метод `lstrip()`

**Метод `lstrip()`** - удаляет в начале строки (слева) все символы пробелов и переноса строк или указанные в аргументе символы.

```python
>>> "    hello world       \n".lstrip()
'hello world       \n'
>>>
```

Это основные методы строк, с которыми мы познакомились на этом занятии.

Конечно это занятие получилось несколько справочным... Но лучше сразу изучить некоторые возможности языка, чтобы потом не изобретать велосипед.
