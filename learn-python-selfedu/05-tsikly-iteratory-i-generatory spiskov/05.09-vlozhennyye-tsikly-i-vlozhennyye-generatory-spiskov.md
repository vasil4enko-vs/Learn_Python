# 5.9. Вложенные циклы и вложенные генераторы списков

## 5.9.1. Вложенные циклы в генераторах списков

Мы продолжаем тему генераторов списков языка Python. На прошлом занятии мы увидели, как можно формировать списки, используя конструкции:

```python
[<способ формирования значения> for <счетчик> in <итерируемый объект>]
```

и

```python
[
    <способ формирования значения>
    for <счетчик> in <итерируемый объект>
    if <условие>
]
```

На этом занятии мы с вами углубимся в эту тему и увидим как можно у этих же генераторов списков прописывать и более сложные конструкции, используя несколько операторов цикла `for`:

```python
[
    <способ формирования значения>
for <переменная_1> in <итерируемый объект> if <условие>
for <переменная_2> in <итерируемый объект> if <условие>
...
for <переменная_N> in <итерируемый объект> if <условие>
]
```

Таким образом все циклы `for`, которые идут после первого цикла `for` являются вложенными один в другой. Т.е. мы здесь имеем множество операторов цикла `for`. Ну и после каждой конструкции оператора цикла `for` можно прописывать необязательное условие.

А теперь на конкретных примерах рассмотрим как работает эта более сложная конструкция с вложенными операторами цикла `for`.

### 5.9.1.1. Простой вариант вложенного цикла for в генераторе списка

В самом простом варианте мы можем сформировать пары чисел `i` и `j`, где `i` будет пробегаться в диапазон от `0` до `2`, а `j` - в диапазон от `0` до `3` (файл `05.09.01.py`):

```python
a = [(i, j) for i in range(3) for j in range(4)]

print(a)
```

Запустим эту программу и получим список состоящий из следующих пар:

```python
[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]
```

Чтобы лучше понять как этот генератор работает запишем его же в несколько строк (файл `05.09.02.py`):

```python
a = [
    (i, j)
    for i in range(3)
    for j in range(4)
]

print(a)
```

Тут хорошо видно, что второй цикл `for` вложен в первый. Т.е. при `i` равном `0` значение `j` пробегается в диапазон от `0` до `3`, т.е. отрабатывает вложенный цикл. По его завершению мы опять переходим во внешний цикл. Теперь `i` принимает значение `1`, а `j` так же заново пробегает диапазон значений от `0` до `3`.

Т.е. здесь работает всё так как и обычные вложенные операторы циклов `for`.

### 5.9.1.2. Вложенный цикл `for` с дополнительным условием

Мало того, здесь у каждого цикла дополнительно можно прописывать условия. Например, в первом цикле `for` возьмём значения `i` только кратные `3` (`05.09.03.py`):

```python
a = [
    (i, j)
    for i in range(3)
    if i % 3 == 0
    for j in range(4)
]

print(a)
```

Запустим эту программу:

```python
[(0, 0), (0, 1), (0, 2), (0, 3)]
```

Как видите, в данном случае был взят только `0`, т.к. лишь `0` - число кратное `3`.

Также мы можем прописывать условия и после второго, вложенного цикла `for`. Допустим возьмём только значения `j` кратные `2` (`05.09.04.py`):

```python
a = [
    (i, j)
    for i in range(3)
    if i % 3 == 0
    for j in range(4)
    if j % 2 == 0
]

print(a)
```

Опять же запустим и увидим такие пары:

```python
[(0, 0), (0, 2)]
```

### 5.9.1.3. Формирование таблицы умножения при помощи вложенного цикла for в генераторе списка

Используя такой подход очень легко сформировать, например, таблицу умножения.

Для этого сформируем F-строку, а циклы оставим прежние. Уберём лишь условия, они нам не нужны (`05.09.05.py`):

```python
a = [
    f"{i}*{j} = {i * j}"
    for i in range(3)
    for j in range(4)
]

print(a)
```

Запустим программу и получим таблицу умножения от `0*0` до `2*3`:

```python
['0*0 = 0', '0*1 = 0', '0*2 = 0', '0*3 = 0', '1*0 = 0', '1*1 = 1', '1*2 = 2', '1*3 = 3', '2*0 = 0', '2*1 = 2', '2*2 = 4', '2*3 = 6']
```

### 5.9.1.4. Преобразование двумерного списка в одномерный при помощи вложенного цикла for в генераторе списка

Рассмотрим другой пример. С помощью такой же конструкции мы можем преобразовать двумерный список в обычный одномерный (`05.09.06.py`):

```python
matrix = [
    [0, 1, 2, 3],
    [10, 11, 12, 13],
    [20, 21, 22, 23],
]

a = [
    x
    for row in matrix
    for x in row
]

print(a)
```

Запустим программу и на выходе увидим одномерный список состоящий из всех чисел двумерного списка:

```python
[0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23]
```

Обратите внимание, мы во втором цикле `for` использовали переменную `row` из первого цикла. Так можно делать. Т.е. мы можем использовать во вложенных циклах переменные объявленные ранее, например во внешнем цикле.

Теперь вы, наверняка, хорошо представляете, как работает конструкция из вложенных циклов.

## 5.9.2. Вложенные генераторы списков

А теперь ещё раз посмотрим на исходную конструкцию генератора списков:

```python
[<способ формирования значения> for <счетчик> in <итерируемый объект>]
```

Как отмечалось ранее, в качестве способа формирования значения можно использовать любые конструкции языка Python. А значит, нам никто мешает использовать здесь ещё один генератор списков и таким образом получить вложенный генератор списка:

```python
[
    [генератор списка]
    for <счетчик> in <итерируемый объект>
]
```

Рассмотрим как это работает, опять же, на конкретных примерах.

### 5.9.2.1. Вложенный генератор списка в качестве способа формирования значения

Зададим две переменные `M` и `N` (`05.09.07.py`):

```python
M, N = 3, 4

matrix = [[a for a in range(M)] for b in range(N)]

print(matrix)
```

Запустим программу:

```python
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
```

В результате мы получили двумерный список.

Почему получился такой результат? Всё очень просто.

Сначала запускается внешний генератор при переменной `b` = `0`, затем вложенный генератор и на выходе вложенный генератор списка выдаёт такую коллекцию: `[0, 1, 2]`, т.к. переменная `a` пробегает диапазон от `0` до `2` включительно.

Далее мы возвращаемся во внешний генератор, переменная `b` будет уже принимать следующее значение `1` и снова запускается вложенный генератор списка, который снова выдаёт такую коллекцию `[0, 1, 2]`.

И снова переходим во внешний цикл, где при переменной `b` = `2` внутренний генератор снова выдаёт - `[0, 1, 2]`.

И при `b` = `3`, происходит последний переход во внутренний генератор списка, который выдаёт `[0, 1, 2]`.

Именно так работает такая конструкция с вложенными генераторами списков.

Но где может пригодиться такой подход?

### 5.9.2.2. Возведение двумерного списка в квадрат

Предположим, что у нас имеется двумерный список и мы хотели бы все значения этого списка возвести в квадрат. Лучше всего, это как раз сделать через вложенный генератор списка (`05.09.08.py`):

```python
A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

A = [[x**2 for x in row] for row in A]

print(A)
```

Здесь во вложенном генераторе мы возвращаем значение `x` в квадрате где `x` будет пробегать вложенные списки. А во внешнем генераторе цикл `for` будет брать, как раз, эти вложенные списки `row`.

Т.е. `row` во внешнем генераторе, будет ссылаться на вложенные списки списка `A`, а `x` во внутреннем генераторе будет перебирать уже отдельные элементы вложенных списков и возводить в квадрат.

Запустив нашу программу мы получим:

```python
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]
```

В результате мы получили тот же самый двумерный список, но уже со значениями в квадрате.

Как вы видите, **главное отличие вложенных генераторов от вложенных циклов в генераторе списка** заключается в том, что в первом случае остаётся двумерный список, а во втором он преобразуется в одномерный.

### 5.9.2.3. Замена строк на столбцы (выполнение транспонирования)

Рассмотрим другой пример.

Предположим, что у нас есть вложенный двумерный список и мы хотели бы все строки заменить на столбцы, т.е. выполнить транспонирование. С помощью вложенного генератора списка сделать это относительно просто (`05.09.09.py`):

```python
A = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]

A = [[row[i] for row in A] for i in range(len(A[0]))]

print(A)
```

Запустив эту программу мы получим на выходе транспонированную матрицу:

```python
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
```

Как это работает?

![Замена строк на столбцы (выполнение транспонирования)](../pictures/05-pictures/05.09/05.09.01.jpg "Замена строк на столбцы (выполнение транспонирования)")

Изначально у нас переменная `i` во внешнем генераторе списка принимает значение `0`, при этом значении у нас во вложенном генераторе формируется строка из значений первого столбца (индекс `0`). Т.к. `row[i]` пробегает как раз по элементам первого столбца. В результате на выходе мы получаем первую строку транспонированной матрицы - `[1, 5, 9]`.

Далее у нас значение `i` увеличивается на единицу, опять переходим во вложенный генератор и во вложенном генераторе мы пробегаемся по значениям уже второго столбца (индекс `1`). И на выходе получаем вторую строку транспонированной матрицы - `[2, 6, 10]`.

И т.д. `i` становится равным `2` проходим по третьему столбцу (индекс `2`) - `[3, 7, 11]` и тоже самое с последним столбцом - `[4, 8, 12]`.

Таким образом работает рассмотренная нами конструкция и мы легко и просто транспонировали эту матрицу.

### 5.9.2.4. Вложенный генератор списка в качестве итерируемого объекта

Другой вариант, когда мы вложенный генератор списка используем в качестве итерируемого объекта.

```python
[
    <способ формирования значения>
    for <счетчик> in [генератор списка]
]
```

Эту конструкцию можно использовать, например, так  (`05.09.10.py`):

```python
g = [u**2 for u in [x + 1 for x in range(5)]]

print(g)
```

Запустим программу:

```python
[1, 4, 9, 16, 25]
```

Мы получили значения квадратов чисел от `1` до `5`.

Т.е. такая конструкция, фактически, описывает поведение вложенных функций, когда одна функция вложена в другую `g(u(x + 1)) = (x + 1)^2`.

Так можно формировать различные вложения генераторов списка.
