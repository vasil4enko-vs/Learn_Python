# 5.8. Генераторы списков (List comprehension)

Мы продолжаем курс по языку программирования Python. На этом занятии мы с вами познакомимся с еще одной довольно полезной и популярной конструкцией - генератором списков. По-английски это записывается как - **List comprehension**

Для лучшего понимания, давайте начнём сразу с конкретного примера.

Предположим, мы хотели бы сформировать список из квадратов целых чисел от `0` до `N`. Используя наши текущие знания, очевидно, это можно было бы сделать, следующим образом (файл `05.08.01.py`):

```python
N = 6
a = [0] * N

for i in range(N):
    a[i] = i**2

print(a)
```

Посмотрим, что у нас получилось:

```python
[0, 1, 4, 9, 16, 25]
```

Да, действительно, у нас получился список, состоящий из квадратов соответствующих чисел. Но это решение - не лучший вариант. Всё это можно реализовать, буквально, в одну строчку (`05.08.02.py`):

```python
N = 6

a = [i**2 for i in range(N)]

print(a)
```

Запустим эту программу:

```python
[0, 1, 4, 9, 16, 25]
```

и у нас получился абсолютно такой же результат.

Как видите, теперь у нас решение записано в одной строчку, наглядно, понятно и кроме того, такой вариант работает заметно быстрее. Поэтому когда мы можем заменить обычный цикл `for` на генератор списков, то лучше использовать генератор списков.

Давайте теперь разберёмся в синтаксисе этого генератора - `[i**2 for i in range(N)]`.

В самом простом виде его можно записать так:

```python
[<способ формирования значения> for <переменная> in <итерируемый объект>]
```

Т.е. в квадратных скобках прописываем способ формирования значения, далее некая переменная после ключевого слова `for` и затем некий итерируемый объект.

Давайте рассмотрим несколько примеров как использовать этот синтаксис непосредственно на практике. Для этого перейдём в Python консоль.

Например, мы можем сформировать список из единиц:

```python
>>> a = [1 for i in range(5)]
>>> a
[1, 1, 1, 1, 1]
>>>
```

или зададим `N = 7` и запишем так:

```python
>>> N = 7
>>> a = [1 for i in range(N)]
>>> a
[1, 1, 1, 1, 1, 1, 1]
>>>
```

Но обратите внимание, что переменная `x` из генератора списка доступна только внутри этого генератора, т.е. внутри квадратных скобок. За пределами генератора переменная `x` пропадает, она становится не доступной.

И действительно:

```python
>>> x
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
>>>
```

видите, возникает ошибка, что переменная `x` не определена.

Т.е., в данном случае, `x` - временная переменная, которая используется исключительно внутри генератора.

Вернёмся к примеру, в котором мы генерировали список из семи единиц. В таком случае обычно используется оператор дублирования строк:

```python
>>> b = [1] * N
>>> b
[1, 1, 1, 1, 1, 1, 1]
>>>
```

у нас получится такой же эффект.

Но в отличии от простого дублирования в List comprehension можно формировать более сложные последовательности. Допустим, сформируем список, состоящий из остатков деления на четыре:

```python
>>> a = [x % 4 for x in range(N)]
>>> a
[0, 1, 2, 3, 0, 1, 2]
>>>
```

Или можем узнать, какие значения чётные и какие нечётные:

```python
>>> a = [x % 2 == 0 for x in range(N)]
>>> a
[True, False, True, False, True, False, True]
>>>
```

В итоге получаем список из булевых значений.

Можем сформировать список из значений какой-нибудь линейной функции:

```python
>>> a = [0.5 * x + 1 for x in range(N)]
>>> a
[1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]
>>>
```

и т.д.

Т.е. с помощью в генераторе списка можно в способе формирования значения указывать любые конструкции языка Python и формировать нужные нам значения. Это очень удобно и часто используется на практике.

И ещё раз повторим, что генератор списков работает быстрее обычного цикла и везде где это возможно необходимо использовать именно генератор списков.

Рассмотрим ещё один пример (файл `05.08.03.py`):

```python
d_inp = input("Целые числа через пробел: ")

a = [int(d) for d in d_inp.split()]

print(a)
```

Запустим, на входе введём числа, например `1 2 3 4` через пробел:

```python
[1, 2, 3, 4]
```

получим список из чисел.

Если же мы уберём в генераторе функцию `int()` (`05.08.04.py`):

```python
d_inp = input("Целые числа через пробел: ")

a = [d for d in d_inp.split()]

print(a)
```

Запустим наш код, введём те же числа через пробел:

```python
['1', '2', '3', '4']
```

получим список состоящий из строк.

Т.е. функция `int()` преобразовывала строки в соответствующие числа.

Перейдём в Python консоль и рассмотрим ещё несколько примеров.

В List comprehension в качестве итерируемого объекта использовать и строку:

```python
>>> a = [d for d in "python"]
>>> a
['p', 'y', 't', 'h', 'o', 'n']
>>>
```

В этом случае берётся каждый символ из строки и получается список символов.

Также мы можем создать список состоящий из кодов этих символов:

```python
>>> a = [ord(d) for d in "python"]
>>> a
[112, 121, 116, 104, 111, 110]
>>>
```

А если мы будем перебирать список, например:

```python
>>> t = ["Я", "б", "Python", "выучил", "только", "за", "то", "что", "есть", "он", "на", "этом", "канале"]
>>> a = [d for d in t]
>>> a
['Я', 'б', 'Python', 'выучил', 'только', 'за', 'то', 'что', 'есть', 'он', 'на', 'этом', 'канале']
>>>
```

то на выходе получим точно такой же список.

А вот если добавить функцию `len()` - определение длины строки:

```python
>>> a = [len(d) for d in t]
>>> a
[1, 1, 6, 6, 6, 2, 2, 3, 4, 2, 2, 4, 6]
>>>
```

получим список длин соответствующих строк.

Так в самом простом варианте можно использовать генераторы списков. Но это не весь их функционал. Дополнительно в генераторах можно прописывать ещё и условия:

```python
>>> a = [x for x in range(-5, 5) if x < 0]
>>> a
[-5, -4, -3, -2, -1]
>>>
```

Мы видим, что указанное условие выполняется, полученный список содержит только отрицательные значения.

Или можем взять только чётные значения:

```python
>>> a = [x for x in range(-5, 5) if x % 2 == 0]
>>> a
[-4, -2, 0, 2, 4]
>>>
```

получаем список состоящий только из чётных чисел.

Можно прописывать составные условия, допустим:

```python
>>> a = [x for x in range(-5, 5) if x % 2 == 0 and x % 3 == 0]
>>> a
[0]
>>>
```

В данном случае список будет состоять из одного числа - `0`.

Попробуем взять другой диапазон:

```python
>>> a = [x for x in range(-6, 7) if x % 2 == 0 and x % 3 == 0]
>>> a
[-6, 0, 6]
>>>
```

Действительно, полученные числа кратны и двум, и трём.

Или такой пример. Допустим у нас есть список городов и нам нужно выбрать из него те города длина названия которых меньше семи символов:

```python
>>> cities = ["Москва", "Тверь", "Рязань", "Ярославль", "Владимир"]
>>> a = [city for city in cities if len(city) < 7]
>>> a
['Москва', 'Тверь', 'Рязань']
>>>
```

Ну и последнее, что мы рассмотрим на этом занятии - это возможность использования внутри генераторов списков тернарного условного оператора.

Так как в способе формирования значения генератора списка мы можем использовать любую конструкцию языка Python, то никто не мешает нам использовать условный тернарный оператор `if-else`.

Рассмотрим такой пример. Допустим, у нас есть список `d = [4, 3, -5, 0, 2, 11, 122, -8, 9]` необходимо создать список со словами "чётное" или "нечётное", т.е. чётные числа заменим на слово "чётное", а нечетные - "нечётное":

```python
>>> d = [4, 3, -5, 0, 2, 11, 122, -8, 9]
>>> a = ["чётное" if x % 2 == 0 else "нечётное" for x in d]
>>> a
['чётное', 'нечётное', 'нечётное', 'чётное', 'чётное', 'нечётное', 'чётное', 'чётное', 'нечётное']
>>>
```

Тернарный оператор сработал и мы получили нужный нам список.

Но полученная запись генератора списков `a = ["чётное" if x % 2 == 0 else "нечётное" for x in d]` получилась не очень читаемой. Его в принципе можно записать и в несколько строк (`05.08.05.py`):

```python
d = [4, 3, -5, 0, 2, 11, 122, -8, 9]

a = ["чётное" if x % 2 == 0 else "нечётное"
     for x in d
     if x > 0
     ]

print(a)
```

Запустим программу и получим список только для чётных чисел:

```python
['чётное', 'нечётное', 'чётное', 'нечётное', 'чётное', 'нечётное']
```

На этом мы завершим наше первое знакомство с генераторами списков. На следующем занятии мы продолжим знакомиться с этой темой.
