# 4.1. Условный оператор `if`. Конструкция `if-else`

## 4.1.1. Условный оператор `if`

На этом занятии мы свами познакомимся с работой условного оператора `if`.

Что он делает и для чего нужен? Помните, на одном из прошлых занятий, мы с вами рассматривали операции сравнения, например, проверяли:

```python
>>> 4 > 2
True
>>>
```

или с переменной:

```python
>>> a = 5
>>> a < 0
False
>>>
```

На выходе получали булевы значения True и False. Но ничего не говорили, как их дальше использовать в программе. Пришло время восполнить этот пробел.

**Оператор `if`** условный оператор (оператор ветвления), который позволяет выполнить группу операторов, при истинности указанного условия.

Синтаксис:

```python
if <condition>:
    <operator  1>
    <operator 2>
    ...
    <operator n>
```

Давайте я сразу поясню эту конструкцию на конкретном примере. Предположим, мы пишем программу для вычисления модуля числа файл `04.01.01.py`:

```python
x = -4
if x < 0:
    x = -x

print(x)
```

После того как мы запустим эту программу, получим:

```python
-4
```

Давайте разберём как работает эта программа.

Смотрите, после оператора `if` записываем условие, то есть, определяем, что x отрицательное число. И если это так, то оператор меньше вернет значение `True`, условие сработает и будет выполнена строчка `x = -x`. А вот следующая строчка (функция `print()`) стоит уже вне этого условия и будет выполняться всегда.

Так как Python "понимает", что находится в блоке условного оператора, а что нет?

Все дело в форматировании текста программы. Когда мы ставим двоеточие, то открывается новый блок, где может располагаться множество операторов. И все конструкции языка Python, что имеют отступ (обычно четыре пробела) относительно оператора `if`, будут располагаться внутри этого блока. Именно поэтому строчка `x = -x` выполняется только при истинности условия `x < 0`, а функция `print()` стоит уже после оператора `if` и выполняется всегда.

Запустив программу мы убедились, что все работает. Получили значение `4`, то есть, условие `x < 0` вернуло значение `True`, оператор `if` сработал и выполнилась строчка `x = -x`.

Чтобы совсем всё было понятно, запустим нашу программу (`04.01.01.py`) в режиме отладки.

Установим на первой строке программы точку останова, для этого в VS Code нужно просто щёлкнуть левой кнопкой мыши на панели левее номеров строк. После чего на этом месте появится красный кружок - точка останова.

**Точка останова** - точка указывающая строку после которой остановится выполнение программы в режиме отладки.

Далее нужно в меню `Выполнить` выбрать пункт `Запустить отладку`.

Или

Запускается режим отладки, программа остановится перед выполнением первой строки `x = -4`. Обратите внимание, что эта строка выделена другим цветом (цвет зависит от используемой вами темы).

Также слева от редактора с нашей программой, открывается панель `Запуск и отладка`, где отображается различная отладочная информация. И в верхней части VS Code появится плавающая панель управления отладкой.

Далее, чтобы выполнить один шаг, если вы используете VS Code, то нужно будет в меню `Выполнить` или в плавающей панели нажать `Шаг с заходом`, ну, или нажать клавишу `F11` на вашей клавиатуре. После этого строка `x = -4` выполнится и мы перейдём к следующей строчке.

В панели слева `Запуск и отладка` VS Code отобразит значение переменой - `x: -4`.

Нажимаем снова клавишу `F11` и мы попадаем внутрь блока условия на строку `x = -x`. Выполняем эту строку нажимая `F11`. И теперь видим, что на панели `Запуск и отладка` наша переменная `x`поменяла значение на `4`.

И в очередной раз нажав клавишу `F11` выполняем последнюю строку программы `print(x)` и результат выводится в консоли. Программа выполнилась.

А теперь в файле `04.01.02.py` мы запишем ту же программу, но значение переменной `x` изменим на `4`:

```python
x = 4
if x < 0:
    x = -x

print(x)
```

И теперь посмотрим как в этих условиях будет выполняться та же самая программа.

Поставим точку останова на первой строке программы и запустим её также в режиме отладки нажав клавишу `F5`.

Выполнение программы остановится перед строкой `x = 4`. Нажмём `F11` - переменной `x` будет присвоено значение `4`. Ещё `F11` - производится проверка условия `x < 0` и так как условие не выполняется, то курсор сразу переходит на строку `print(x)`, минуя строку `x = -x` (т.е. эта строка выполнена не была). И нажав ещё раз `F11` мы выполним последнюю строку `print(x)`, что выведет результат выполнения нашей программы `4` в консоль.

А теперь давайте посмотрим, что будет если мы в файл `04.01.03.py` запишем программу аналогичную программе из файла `04.01.01.py`, но последнюю строку `print(x)` переместим в блок операторов выполняемых в случае истинности условия `x < 0`:

```python
x = -4
if x < 0:
    x = -x
    print(x)
```

И снова поставив как и в предыдущих случаях точку останова запустим программу в режиме отладки нажав клавишу `F5`. Нажимаем `F11`, естественно условие выполняется и у нас отработают оба оператора и `x = -x` и функция `print(x)`. В итоге в консоли мы видим значение `4`.

А если в файле `04.01.04.py` запишем эту же программу, но заменим значение переменной `x` на `4`:

```python
x = 4
if x < 0:
    x = -x
    print(x)
```

И в режиме отладки запустим полученную программу, то смотрите что у нас получится. Когда мы дойдём до проверки условия получим значение `False`. Поэтому весь блок оператора `if` пропускается и программа завершается. При этом в консоль ничего не выводится, т.к. `print(x)` теперь находится внутри блока условного оператора.

А если убрать этот отступ, как у нас было в файле `04.01.02.py` и запустить программу, то функция `print(x)` отработает и выведет в консоль значение `4`.

Т.е. вы видите, как форматирование кода программы влияет на её поведение.

Чтобы всё стало окончательно понятно рассмотрим ещё пару примеров.

Запишем в файл `04.01.05.py` такую программу:

```python
a = float(input("a: "))
b = float(input("b: "))

if a < b:
    a, b = b, a

print(a, b)
```

Запустим её и введём значения переменных `a = 3` и `b = 4`.

Результатом выполнения команды будет:

```python
4.0 3.0
```

Так получилось потому, что условие `if a < b` вернуло `True` и строка `a, b = b, a` поменяло значения в наших переменных местами.

Если же снова запустить эту программу и ввести такие значения `a = 10` и `b = 3`, то получим:

```python
10.0 3.0
```

Здесь мы видим, что строчка `a, b = b, a` не сработала, потому что условие `if a < b` стало ложным - `False`.

Вот таким образом работает этот оператор `if`.

Также мы можем применять и более сложные условия, например (файл `04.01.06.py`):

```python
x = int(input())

if x >= -4 and x <= 10:
    print("x в диапазоне [-4; 10]")
```

При появлении запроса введём значение `2` и получим:

```python
x в диапазоне [-4; 10]
```

А теперь в этой же программе введём число не входящее в указанный в программе, например `-5`. И в этом случае программа ничего не выведет, т.к. наше условие не выполнилось.

Также эту программу можно записать и в таком виде:

```python
x = int(input())
if -4 <= x <= 10:
    print("x в диапазоне [-4; 10]")
```

Результат будет тот же.

В качестве условия можно записывать любые конструкции, которые можно интерпретировать как истину `True` и ложь `False`. Даже так, просто указав числовое значение (файл `04.01.07.py`):

```python
x = int(input())
if x:
    print("x = True")
```

Мы здесь получим истину, если `x` не является пустым значением, для чисел не равен нулю.

Также в условиях можно явно прописывать булево значение (файл `04.01.08.py`):

```python
x = int(input())
    if True:
        print("x = True")
```

В этом случае условие будет срабатывать всегда, не зависимо от значения переменной `x`. Конечно это лишь пример и практического смысла в таком условии нет.

И наконец, мы можем использовать операторы проверки для списков. Например, студент имеет следующие оценки по результатам сдачи сессии `marks = [3, 3, 4, 2, 4]` и мы хотим узнать будет ли он отчислен. Для этого используем программу из файла `04.01.09.py`:

```python
marks = [3, 3, 4, 2, 4]

if 2 in marks:
    print("Студент будет отчислен")
```

Результатом выполнения программы будет:

```python
Студент будет отчислен
```

## 4.1.2. Условный оператор `else`

А теперь допустим нам бы хотелось, чтобы в противном случае, когда нет ни одной двойки выводилось бы сообщение `Студент успешно сдал сессию`.

Как это можно сделать?

Это можно реализовать при помощи специального оператора `else` (файл `04.01.10.py`):

```python
marks = [3, 3, 4, 2, 4]

if 2 in marks:
    print("Студент будет отчислен")
else:
    print("Студент успешно сдал сессию")
```

Результат получился:

```python
Студент будет отчислен
```

Так получилось потому, что условие `if 2 in marks` выполнилось, т.к. `2` есть в списке `marks`, а блок `else` был проигнорирован.

Но если вместо двойки поставить, допустим `4` (файл `04.01.11.py`):

```python
marks = [3, 3, 4, 4, 4]

if 2 in marks:
    print("Студент будет отчислен")
else:
    print("Студент успешно сдал сессию")
```

то получим:

```python
Студент успешно сдал сессию
```

Т.е. блок `else` выполняется тогда, когда первое условие не выполнилось - приняло значение `False`. И наоборот, если условие сработало, то блок `else` не выполняется. При такой конструкции выполняется либо первый блок, либо второй, но не оба вместе. Т.е. здесь определены два взаимоисключающих случая.

Или другой пример (файл `04.01.12.py`):

```python
x = int(input())

if x < 0:
    print("x - отрицательное число")
else:
    print("x - не отрицательное число")
```

Здесь мы снова видим два взаимоисключающих случая, т.к. `x` одновременно не может быть отрицательным и не отрицательным числом.

Запустим эту программу, введём в консоль какое-либо значение, например `1` и получим:

```python
x - не отрицательное число
```

Действительно, условие `if x < 0` вернуло `False`, поэтому мы перешли на блок `else` и выполнился `print("x - не отрицательное число")`.

А если мы введём отрицательное число, например `-1`, то получим:

```python
x - отрицательное число
```

Ну, и в последнем примере этого занятия проверим `x` на чётность (файл `04.01.13.py`):

x = int(input())

```python
if x % 2 == 0:
    print("x - чётное число")
else:
    print("x - не чётное число")
```

Запустим эту программу, введём в консоль какое-либо значение, например `3` и видим:

```python
x - не чётное число
```

Как видите всё сработало так как и ожидалось.

Снова запустим эту программу, введём чётное число, допустим `8`:

```python
x - чётное число
```

Видим, что `x` является чётным числом.

Т.е. когда срабатывает условие, то выполняется действие из блока `if`. В противном случае выполняется действие из блока `else`.
