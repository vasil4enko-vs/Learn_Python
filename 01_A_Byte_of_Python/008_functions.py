"""Функции"""

"""Функции - это многократно используемые фрагменты программы. Они
позволяют дать имя определённому блоку команд с тем, чтобы впоследствии
запускать этот блок по указанному имени в любом месте программы и сколь
угодно много раз. Это называется вызовом функции. Мы уже использовали
много встроенных функций, как то len и range.

Функция - это, пожалуй, наиболее важный строительный блок любой
нетривиальной программы (на любом языке программирования), поэтому в
этой главе мы рассмотрим различные аспекты функций.

Функции определяются при помощи зарезервированного слова def. После
этого слова указывается имя функции, за которым следует пара скобок, в
которых можно указать имена некоторых переменных, и заключительное
двоеточие в конце строки. Далее следует блок команд, составляющих
функцию. На примере можно видеть, что на самом деле это очень просто:

Пример: (сохраните как function1.py)
"""


def say_hello():
    """Распечатывает 'Привет, Мир!'."""
    print('Привет, Мир!')  # блок, принадлежащий функции
# Конец функции


say_hello()  # Вызов функции
say_hello()  # ещё один вызов функции

"""Вывод:"""

"""$ python function1.py
    Привет, Мир!
    Привет, Мир!
"""

"""Как это работает:"""

"""Мы определили функцию с именем say_hello, используя описанный выше
    синтаксис. Эта функция не принимает параметров, поэтому в скобках не
    объявлены какие-либо переменные. Параметры функции - это некие
    входные данные, которые мы можем передать функции, чтобы получить
    соответствующий им результат.

    Обратите внимание, что мы можем вызывать одну и ту же функцию много
    раз, а значит нет необходимости писать один и тот же код снова и
    снова.
"""

"""Параметры функций"""

"""Функции могут принимать параметры, т.е. некоторые значения,
передаваемые функции для того, чтобы она что-либо сделала с ними. Эти
параметры похожи на переменные, за исключением того, что значение этих
переменных указывается при вызове функции, и во время работы функции им
уже присвоены их значения.

Параметры указываются в скобках при объявлении функции и разделяются
запятыми. Аналогично мы передаём значения, когда вызываем функцию.
Обратите внимание на терминологию: имена, указанные в объявлении
функции, называются параметрами, тогда как значения, которые вы
передаёте в функцию при её вызове, - аргументами.

Пример: (сохраните как func_param.py)
"""


def print_max(a, b):
    """
    Сравнение переменных a и b.

    Args:
        a (int): Первая переменная
        b (int): Вторая переменная
    """
    if a > b:
        print(a, 'максимально')
    elif a == b:
        print(a, 'равно', b)
    else:
        print(b, 'максимально')


print_max(3, 4)  # прямая передача значений

x = 5
y = 7

print_max(x, y)  # передача переменных в качестве аргументов

"""Вывод:"""

"""$ python func_param.py
    4 максимально
    7 максимально
"""

"""Как это работает:"""

"""Здесь мы определили функцию с именем print_max, которая использует
    два параметра с именами a и b. Мы находим наибольшее число с
    применением простого оператора if..else и выводим это число.

    При первом вызове функции print_max мы напрямую передаём числа в
    качестве аргументов. Во втором случае мы вызываем функцию с
    переменными в качестве аргументов. print_max(x, y) назначает
    значение аргумента x параметру a, а значение аргумента y - параметру
    b. В обоих случаях функция print_max работает одинаково.
"""

"""Локальные переменные"""

"""При объявлении переменных внутри определения функции, они никоим
образом не связаны с другими переменными с таким же именем за пределами
функции - т.е. имена переменных являются локальными в функции. Это
называется областью видимости переменной. Область видимости всех
переменных ограничена блоком, в котором они объявлены, начиная с точки
объявления имени.

Пример: (сохраните как func_local.py)
"""

x = 50
print('Глобальный x =', x)


def func(x):
    """
    Объяснение локальных переменных.

    Args:
        x (int): Переменная
    """
    print('Всё ещё глобальный x =', x)
    x = 2
    print('Замена глобального x на локальный, теперь x =', x)


func(x)
print('По-прежнему х глобальный и равен', x)

"""Вывод:"""

"""$ python func_local.py
    Глобальный x = 50
    Всё ещё глобальный x = 50
    Замена глобального x на локальный, теперь x = 2
    По-прежнему х глобальный и равен 50
"""

"""Как это работает:"""

"""При первом выводе значения, присвоенного x, Python использует
    значение параметра 50, объявленного в основном блоке, выше
    определения функции.

    Второй вывод значения, присвоенного x выводит тоже, что и в первом
    выводе -
    50.

    Далее мы назначаем x значение 2. Имя x локально для нашей функции.
    Поэтому когда мы заменяем глобальное значение x в функции, x,
    объявленный в основном блоке, остаётся незатронутым. Но в текущем
    блоке параметр становится x = 2.

    Последним вызовом функции print мы выводим значение x, указанное в
    основном блоке, подтверждая таким образом, что оно не изменилось при
    локальном присваивании значения в ранее вызванной функции. Вывод -
    50.
"""

"""Зарезервированное слово "global"""

"""Чтобы присвоить некоторое значение переменной, определённой на высшем
уровне программы (т.е. не в какой-либо области видимости, как то функции
или классы), необходимо указать Python, что её имя не локально, а
глобально (global). Сделаем это при помощи зарезервированного слова
global. Без применения зарезервированного слова global невозможно
присвоить значение переменной, определённой за пределами функции.

Можно использовать уже существующие значения переменных, определённых за
пределами функции (при условии, что внутри функции не было объявлено
переменной с таким же именем). Однако, это не приветствуется, и его
следует избегать, поскольку человеку, читающему текст программы, будет
непонятно, где находится объявление переменной. Использование
зарезервированного слова global достаточно ясно показывает, что
переменная объявлена в самом внешнем блоке.

Пример: (сохраните как func_global.py)
"""

x = 50


def func():
    """Объяснение как заменить глобальную переменную на локальную."""
    global x
    print('x = ', x)
    x = 2
    print('Заменяем глобальное значение x на локальное. Теперь x =', x)


func()
print('Глобальное значение изменилось, x =', x)

"""Вывод:"""

"""$ python func_global.py
    x =  50
    Заменяем глобальное значение x на локальное. Теперь x = 2
    Глобальное значение изменилось, x = 2
"""

"""Как это работает:"""

"""Зарезервированное слово global используется для того, чтобы объявить,
что x - это глобальная переменная, а значит, когда мы присваиваем
значение имени x внутри функции, это изменение отразится на значении
переменной x в основном блоке программы. Используя одно
зарезервированное слово global, можно объявить сразу несколько
переменных: global x, y, z.
"""

"""Зарезервированное слово "nonlocal"""

"""Мы увидели, как получать доступ к переменным в локальной и глобальной
области видимости. Есть ещё один тип области видимости, называемый
"нелокальной" (nonlocal) областью видимости, который представляет собой
нечто среднее между первыми двумя. Нелокальные области видимости
встречаются, когда вы определяете функции внутри функций.

Поскольку в Python всё является выполнимым кодом, вы можете определять
функции где угодно.

Давайте рассмотрим пример:  (сохраните как 01_func_nonlocal.py
"""

x = 1


def func_outer():
    """Объяснение как сохранить глобальную переменную."""
    x = 2
    print('x равно', x)

    def func_inner():
        """Не локальное присвоение значения переменной."""
        nonlocal x
        x = 5

    func_inner()
    print('Локальное x сменилось на', x)


func_outer()

print('Глобальное x =', x)


func_outer()

print('Глобальное x =', x)

"""Вывод:"""

"""$ python 01-func_nonlocal.py
    x равно 2
    Локальное x сменилось на 5
    Глобальное x = 1
"""

"""Как это работает:"""

"""Когда мы находимся внутри func_inner, переменная x, определённая в
    первой строке func_outer находится ни в локальной области видимости
    (определение переменной не входит в блок func_inner), ни в
    глобальной области видимости (она также и не в основном блоке
    программы). Мы объявляем, что хотим использовать именно эту
    переменную x, следующим образом: nonlocal x.

    Попробуйте заменить "nonlocal x" на "global x" (02_func_global.py),
    а затем удалить это зарезервированное слово, и пронаблюдайте за
    разницей между этими двумя случаями.
"""

"""Значения аргументов по умолчанию"""

"""Зачастую часть параметров функций могут быть необязательными, и для
них будут использоваться некоторые заданные значения по умолчанию, если
пользователь не укажет собственных. Этого можно достичь с помощью
значений аргументов по умолчанию. Их можно указать, добавив к имени
параметра в определении функции оператор присваивания (=) с последующим
значением.

Обратите внимание, что значение по умолчанию должно быть константой. Или
точнее говоря, оно должно быть неизменным[1] - это объясняется подробнее
в последующих главах. А пока запомните это.

Пример: (сохраните как func_default.py)
"""


def say(message='Сообщение', times=1):
    """
    Вывод на экран строки указанное число раз.

    Args:
        message (str, optional): Текст. Defaults to 'Сообщение'.
        times (int, optional): Количество сообщений. Defaults to 1.
    """
    print(message * times)


say()
say('Привет!')
say('Мир! ', 5)

"""Вывод:"""

"""$ python func_default.py
    Сообщение
    Привет!
    Мир! Мир! Мир! Мир! Мир!
"""

"""Как это работает:"""

"""Функция под именем say используется для вывода на экран строки
    "Сообщение" указанное число раз. Если мы не указываем значения, по
    умолчанию строка выводится один раз. Мы достигаем этого указанием
    значения аргумента по умолчанию, равного 1 для параметра times[2].

    При первом вызове say всё выводится по умолчанию. При втором вызове
    say мы указываем только строку, и функция выводит её один раз. В
    третьем вызове say мы указываем также и аргумент 5, обозначая таким
    образом, что мы хотим сказать[3] фразу 5 раз.
"""

"""Важно: Значениями по умолчанию могут быть снабжены только параметры,
находящиеся в конце списка параметров. Таким образом, в списке
параметров функции параметр со значением по умолчанию не может
предшествовать параметру без значения по умолчанию. Это связано с тем,
что значения присваиваются параметрам в соответствии с их положением.
Например, def func(a, b=5) допустимо, а def func(a=5, b) - не допустимо.
"""

"""Ключевые аргументы"""

"""Если имеется некоторая функция с большим числом параметров, и при её
вызове требуется указать только некоторые из них, значения этих
параметров могут задаваться по их имени – это называется ключевые
параметры. В этом случае для передачи аргументов функции используется
имя (ключ) вместо позиции (как было до сих пор).

Есть два преимущества такого подхода: во-первых, использование функции
становится легче, поскольку нет необходимости отслеживать порядок
аргументов; во-вторых, можно задавать значения только некоторым
избранным аргументам, при условии, что остальные параметры имеют
значения аргумента по умолчанию.

Пример: (сохраните как func_key.py)
"""


def func(a, b=5, c=10):
    """
    Функция с параметрами по-умолчанию.

    Args:
        a (int, optional): Первый параметр
        b (int, optional): Второй параметр. Defaults to 5.
        c (int, optional): Третий параметр. Defaults to 10.
    """
    print('a =', a, 'b =', b, 'c = ', c)


func(3, 7)
func(25, c=24)
func(c=50, a=100)

"""Вывод:"""

"""$ python func_key.py
    a = 3 b = 7 c =  10
    a = 25 b = 5 c =  24
    a = 100 b = 5 c =  50
"""

"""Как это работает:"""

"""Функция с именем func имеет один параметр без значения по умолчанию,
    за которым следуют два параметра со значениями по умолчанию.

    При первом вызове, func(3, 7), параметр a получает значение 3,
    параметр b получает значение 7, а c получает своё значение по
    умолчанию, равное 10.

    При втором вызове func(25, c=24) переменная a получает значение 25 в
    силу позиции аргумента. После этого параметр c получает значение 24
    по имени, т.е. как ключевой параметр. Переменная b получает значение
    по умолчанию, равное 5.

    При третьем обращении func(c=50, a=100) мы используем ключевые
    аргументы для всех указанных значений. Обратите внимание на то, что
    мы указываем значение для параметра c перед значением для a, даже
    несмотря на то, что в определении функции параметр a указан раньше
    c.
"""

"""Переменное число параметров"""

"""Иногда бывает нужно определить функцию, способную принимать любое
число параметров. Этого можно достичь при помощи звёздочек (сохраните
как func_varargs.py):
"""


def total(a=5, *numbers, **phonebook):
    """
    Значения аргументов по умолчанию.

    Args:
        a (int, optional): [description]. Defaults to 5.
        numbers (int, optional): [description].
        phonebook (int, optional): [description].
    """
    print('a:', a)
    # проход по всем элементам кортежа:
    for single_item in numbers:
        print('single_item:', single_item)
    # проход по всем элементам словаря:
    for first_part, second_part in phonebook.items():
        print(f'{first_part}:', second_part)


print(total(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560))

"""Вывод:"""

"""$ python func_varargs.py
    a: 10
    single_item: 1
    single_item: 2
    single_item: 3
    Jack: 1123
    John: 2231
    Inge: 1560
    None
"""

"""Как это работает:"""

"""Когда мы объявляем параметр со звёздочкой (например, *arg), все
    позиционные аргументы начиная с этой позиции и до конца будут
    собраны в кортеж под именем param.

    Аналогично, когда мы объявляем параметры с двумя звёздочками
    (**kwarg), все ключевые аргументы начиная с этой позиции и до конца
    будут собраны в словарь под именем param.

    Мы изучим кортежи и словари в одной из последующих глав
    (https://wombat.org.ua/AByteOfPython/data_structures.html#data-structures).
"""

"""Только ключевые параметры"""

"""Если некоторые ключевые параметры должны быть доступны только по
ключу, а не как позиционные аргументы, их можно объявить после параметра
со звёздочкой (сохраните как keyword_only.py):
"""


def total(initial=5, *numbers, extra_number):
    """
    Функция с ошибкой.

    Args:
        extra_number (int, optional): Не указано значение аргумента.
        initial (int, optional): Первый параметр. Defaults to 5.
    """
    count = initial
    for number in numbers:
        count += number
    count += extra_number
    print(count)


total(10, 1, 2, 3, extra_number=50)
total(10, 1, 2, 3)
# Вызовет ошибку, поскольку мы не указали значение аргумента по
# умолчанию для 'extra_number'.

"""Вывод:"""

"""python keyword_only.py
    66
    Traceback (most recent call last):
    File "/home/scyth1an/projects/GitHub -
    Python/Learn_Python/01-A_Byte_of_Python/008-functions/09-key_parameters_only/keyword_only.py",
    line 10, in <module> total(10, 1, 2, 3)
    TypeError: total() missing 1 required keyword-only argument:
    'extra_number'
"""

"""Как это работает:"""

"""Объявление параметров после параметра со звёздочкой даёт только
    ключевые аргументы. Если для таких аргументов не указано значение по
    умолчанию, и оно не передано при вызове, обращение к функции вызовет
    ошибку, в чём мы только что убедились.

    Обратите внимание на использование +=, который представляет собой
    сокращённый оператор, позволяющий вместо x = x + y просто написать x
    += y.

    Если вам нужны аргументы, передаваемые только по ключу, но не нужен
    параметр со звёздочкой, то можно просто указать одну звёздочку без
    указания имени: def total(initial=5, *, extra_number).
"""

"""Оператор 'return'"""

"""Оператор return используется для возврата[5] из функции, т.е. для
прекращения её работы и выхода из неё. При этом можно также вернуть
некоторое значение из функции.

Пример: (сохраните как func_return.py)
"""


def maximum(x, y):
    """
    Возвращает большее число.

    Args:
        x (int): Первое число.
        y (int): Второе число

    Returns:
        int, str: Большее число, Числа равны.
    """
    if x > y:
        return x
    elif x == y:
        return 'Числа равны'
    else:
        return y


print(maximum(2, 3))

"""Вывод:"""

"""$ python func_return.py
    3
"""

"""Как это работает:"""

"""Функция maximum возвращает максимальный из двух параметров, которые в
    данном случае передаются ей при вызове. Она использует обычный
    условный оператор if..else для определения наибольшего числа, а
    затем возвращает это число.
"""

"""Обратите внимание, что оператор return без указания возвращаемого
значения эквивалентен выражению return None. None - это специальный тип
данных в Python, обозначающий ничего. К примеру, если значение
переменной установлено в None, это означает, что ей не присвоено
никакого значения.

Каждая функция содержит в неявной форме оператор return None в конце,
если вы не указали своего собственного оператора return. В этом можно
убедиться, запустив print(some_function()), где функция someFunction -
это какая-нибудь функция, не имеющая оператора return в явном виде.
Например:
"""


def some_function():  # Пустая функция в учебных целях
    pass


"""Оператор pass используется в Python для обозначения пустого блока
команд.
"""

"""Примечание: Существует встроенная функция max, в которой уже
реализован функционал "поиск максимума", так что пользуйтесь этой
встроенной функцией, где это возможно.
"""

"""Строки документации"""

"""Python имеет остроумную особенность, называемую строками
документации, обычно обозначаемую сокращённо docstrings. Это очень
важный инструмент, которым вы обязательно должны пользоваться, поскольку
он помогает лучше документировать программу и облегчает её понимание.
Поразительно, но строку документации можно получить, например, из
функции, даже во время выполнения программы!
"""

"""Пример: (сохраните как func_doc.py)"""


def print_max(x, y):
    """
    Выводит максимальное из двух чисел.

    Args:
        x (int): Первое число.
        y (int): Второе число.
    """
    x = int(x)  # Конвертируем в целые, если возможно
    y = int(y)

    if x > y:
        print(x, 'наибольшее')
    elif x < y:
        print(y, 'наибольшее')
    else:
        print('Числа равны.')


print_max(3, 5)
print(print_max.__doc__)

"""Вывод:"""

"""$ python func_doc.py
    5 наибольшее
    Выводит максимальное из двух чисел.
    Оба значения должны быть целыми числами.
"""

"""Как это работает:"""

"""Строка в первой логической строке функции является строкой
    документации для этой функции. Обратите внимание на то, что строки
    документации применимы также к модулям и классам, о которых мы
    узнаем в соответствующих главах.

    Строки документации принято записывать в форме многострочной[7]
    строки, где первая строка начинается с заглавной буквы и
    заканчивается точкой. Вторая строка оставляется пустой, а подробное
    описание начинается с третьей. Вам настоятельно рекомендуется
    следовать такому формату для всех строк документации всех ваших
    нетривиальных функций.

    Доступ к строке документации функции print_max можно получить с
    помощью атрибута этой функции (т.е. имени, принадлежащего ей)
    __doc__ (обратите внимание на двойное подчёркивание). Просто
    помните, что Python представляет всё в виде объектов, включая
    функции. Мы узнаем больше об объектах в главе о классах.
"""

"""Если вы пользовались функцией help() в Python, значит вы уже видели
строки документации. Эта функция просто-напросто считывает атрибут
__doc__ соответствующей функции и аккуратно выводит его на экран. Вы
можете проверить её на рассмотренной выше функции: просто включите
help(printMax) в текст программы. Не забудьте нажать клавишу q для
выхода из справки (help).

Точно так же автоматические инструменты могут получать документацию из
программы. Именно поэтому я настоятельно рекомендую вам использовать
строки документации для любой нетривиальной функции, которую вы пишете.
Команда pydoc, поставляемая вместе с пакетом Python, работает аналогично
функции help().
"""

"""Аннотации"""

"""Функции имеют ещё одну дополнительную возможность, называемую
аннотациями, которые предоставляют отличный способ сопровождения каждого
параметра, равно как и возвращаемого значения дополнительной
информацией. Поскольку сам язык Python не интерпретирует эти аннотации
каким-либо способом (этот функционал отводится посторонним библиотекам),
мы опустим эту возможность из нашего обсуждения. Если вам интересно
почитать об аннотациях, просмотрите PEP 3107
(https://www.python.org/dev/peps/pep-3107/).
"""

"""Резюме"""

"""Мы рассмотрели достаточно много аспектов функций, но тем не менее, вы
должны понимать, что это далеко не все их аспекты. В то же время, мы
охватили большинство того, с чем вы будете сталкиваться при повседневном
использовании функций в Python.

Далее мы увидим, как использовать и создавать модули Python.
"""

"""Примечания"""

""" [1]  "immutable" в терминологии Python (прим. перев.)
    [2] times - англ. "раз" (прим. перев.)
    [3] say - англ. "сказать" (прим. перев.)
    [4] VarArgs - от англ. "Variable number of Arguments" - "переменное
    число аргументов" (прим. перев.) [5] return - англ. "возврат" (прим.
    перев.) [6] DocString - от англ. "Documentation String" - "строка
    документации" (прим. перев.) [7] т.е. строки, содержащей символы
    перевода строки. (прим. перев)
"""
